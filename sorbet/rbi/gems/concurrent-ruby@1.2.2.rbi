# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `concurrent-ruby` gem.
# Please instead update this file by running `bin/tapioca gem concurrent-ruby`.

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/constants.rb#1
module Concurrent
  extend ::Concurrent::Utility::EngineDetector
  extend ::Concurrent::Utility::NativeExtensionLoader
  extend ::Logger::Severity
  extend ::Concurrent::Concern::Logging
  extend ::Concurrent::Concern::Deprecation

  private

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/tvar.rb#139
  def abort_transaction; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/tvar.rb#82
  def atomically; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/dataflow.rb#56
  def call_dataflow(method, executor, *inputs, &block); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/dataflow.rb#34
  def dataflow(*inputs, &block); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/dataflow.rb#44
  def dataflow!(*inputs, &block); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/dataflow.rb#39
  def dataflow_with(executor, *inputs, &block); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/dataflow.rb#49
  def dataflow_with!(executor, *inputs, &block); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/tvar.rb#144
  def leave_transaction; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/monotonic_time.rb#15
  def monotonic_time(unit = T.unsafe(nil)); end

  class << self
    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/tvar.rb#139
    def abort_transaction; end

    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/tvar.rb#82
    def atomically; end

    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/dataflow.rb#56
    def call_dataflow(method, executor, *inputs, &block); end

    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/logging.rb#37
    def create_simple_logger(level = T.unsafe(nil), output = T.unsafe(nil)); end

    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/logging.rb#69
    def create_stdlib_logger(level = T.unsafe(nil), output = T.unsafe(nil)); end

    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/dataflow.rb#34
    def dataflow(*inputs, &block); end

    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/dataflow.rb#44
    def dataflow!(*inputs, &block); end

    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/dataflow.rb#39
    def dataflow_with(executor, *inputs, &block); end

    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/dataflow.rb#49
    def dataflow_with!(executor, *inputs, &block); end

    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/configuration.rb#48
    def disable_at_exit_handlers!; end

    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/configuration.rb#83
    def executor(executor_identifier); end

    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/configuration.rb#55
    def global_fast_executor; end

    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/configuration.rb#66
    def global_immediate_executor; end

    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/configuration.rb#62
    def global_io_executor; end

    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/logging.rb#109
    def global_logger; end

    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/logging.rb#113
    def global_logger=(value); end

    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/configuration.rb#73
    def global_timer_set; end

    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/tvar.rb#144
    def leave_transaction; end

    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/monotonic_time.rb#15
    def monotonic_time(unit = T.unsafe(nil)); end

    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/lock_local_var.rb#7
    def mutex_owned_per_thread?; end

    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/configuration.rb#87
    def new_fast_executor(opts = T.unsafe(nil)); end

    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/configuration.rb#98
    def new_io_executor(opts = T.unsafe(nil)); end

    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/processor_counter.rb#107
    def physical_processor_count; end

    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/processor_counter.rb#86
    def processor_count; end

    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/processor_counter.rb#68
    def processor_counter; end

    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/logging.rb#63
    def use_simple_logger(level = T.unsafe(nil), output = T.unsafe(nil)); end

    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/logging.rb#96
    def use_stdlib_logger(level = T.unsafe(nil), output = T.unsafe(nil)); end
  end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/exchanger.rb#38
class Concurrent::AbstractExchanger < ::Concurrent::Synchronization::Object
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/exchanger.rb#44
  def initialize; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/exchanger.rb#69
  def exchange(value, timeout = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/exchanger.rb#80
  def exchange!(value, timeout = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/exchanger.rb#109
  def try_exchange(value, timeout = T.unsafe(nil)); end

  private

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/exchanger.rb#122
  def do_exchange(value, timeout); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/exchanger.rb#41
Concurrent::AbstractExchanger::CANCEL = T.let(T.unsafe(nil), Object)

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/abstract_executor_service.rb#10
class Concurrent::AbstractExecutorService < ::Concurrent::Synchronization::LockableObject
  include ::Logger::Severity
  include ::Concurrent::Concern::Logging
  include ::Concurrent::ExecutorService
  include ::Concurrent::Concern::Deprecation

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/abstract_executor_service.rb#23
  def initialize(opts = T.unsafe(nil), &block); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/abstract_executor_service.rb#72
  def auto_terminate=(value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/abstract_executor_service.rb#67
  def auto_terminate?; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/abstract_executor_service.rb#18
  def fallback_policy; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/abstract_executor_service.rb#42
  def kill; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/abstract_executor_service.rb#20
  def name; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/abstract_executor_service.rb#52
  def running?; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/abstract_executor_service.rb#37
  def shutdown; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/abstract_executor_service.rb#62
  def shutdown?; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/abstract_executor_service.rb#57
  def shuttingdown?; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/abstract_executor_service.rb#32
  def to_s; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/abstract_executor_service.rb#47
  def wait_for_termination(timeout = T.unsafe(nil)); end

  private

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/abstract_executor_service.rb#85
  def fallback_action(*args); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/abstract_executor_service.rb#126
  def ns_auto_terminate?; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/abstract_executor_service.rb#106
  def ns_execute(*args, &task); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/abstract_executor_service.rb#122
  def ns_kill_execution; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/abstract_executor_service.rb#114
  def ns_shutdown_execution; end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/abstract_executor_service.rb#15
Concurrent::AbstractExecutorService::FALLBACK_POLICIES = T.let(T.unsafe(nil), Array)

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/locals.rb#35
class Concurrent::AbstractLocals
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/locals.rb#36
  def initialize; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/locals.rb#89
  def fetch(index); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/locals.rb#71
  def free_index(index); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/locals.rb#55
  def next_index(local); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/locals.rb#102
  def set(index, value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/locals.rb#43
  def synchronize; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/locals.rb#48
  def weak_synchronize; end

  private

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/locals.rb#112
  def local_finalizer(index); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/locals.rb#128
  def locals; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/locals.rb#133
  def locals!; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/locals.rb#119
  def thread_fiber_finalizer(array_object_id); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#145
class Concurrent::Agent < ::Concurrent::Synchronization::LockableObject
  include ::Concurrent::Concern::Observable

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#220
  def initialize(initial, opts = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#331
  def <<(action); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#350
  def await; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#363
  def await_for(timeout); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#377
  def await_for!(timeout); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#229
  def deref; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#240
  def error; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#184
  def error_mode; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#402
  def failed?; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#294
  def post(*args, &action); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#240
  def reason; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#424
  def restart(new_value, opts = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#278
  def send(*args, &action); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#287
  def send!(*args, &action); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#294
  def send_off(*args, &action); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#302
  def send_off!(*args, &action); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#311
  def send_via(executor, *args, &action); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#319
  def send_via!(executor, *args, &action); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#402
  def stopped?; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#229
  def value; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#393
  def wait(timeout = T.unsafe(nil)); end

  private

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#510
  def enqueue_action_job(action, args, executor); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#516
  def enqueue_await_job(latch); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#543
  def execute_next_job; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#576
  def handle_error(error); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#529
  def ns_enqueue_job(job, index = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#584
  def ns_find_last_job_for_thread; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#490
  def ns_initialize(initial, opts); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#539
  def ns_post_next_job; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#570
  def ns_validate(value); end

  class << self
    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#449
    def await(*agents); end

    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#463
    def await_for(timeout, *agents); end

    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#482
    def await_for!(timeout, *agents); end
  end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#154
Concurrent::Agent::AWAIT_ACTION = T.let(T.unsafe(nil), Proc)

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#151
Concurrent::Agent::AWAIT_FLAG = T.let(T.unsafe(nil), Object)

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#157
Concurrent::Agent::DEFAULT_ERROR_HANDLER = T.let(T.unsafe(nil), Proc)

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#160
Concurrent::Agent::DEFAULT_VALIDATOR = T.let(T.unsafe(nil), Proc)

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#148
Concurrent::Agent::ERROR_MODES = T.let(T.unsafe(nil), Array)

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#167
class Concurrent::Agent::Error < ::StandardError
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#168
  def initialize(message = T.unsafe(nil)); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#163
class Concurrent::Agent::Job < ::Struct
  def action; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#163
  def action=(_); end

  def args; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#163
  def args=(_); end

  def caller; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#163
  def caller=(_); end

  def executor; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#163
  def executor=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#176
class Concurrent::Agent::ValidationError < ::Concurrent::Agent::Error
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/agent.rb#177
  def initialize(message = T.unsafe(nil)); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/array.rb#53
class Concurrent::Array < ::Array; end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/array.rb#22
Concurrent::ArrayImplementation = Array

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/async.rb#217
module Concurrent::Async
  mixes_in_class_methods ::Concurrent::Async::ClassMethods

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/async.rb#412
  def async; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/async.rb#430
  def await; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/async.rb#430
  def call; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/async.rb#412
  def cast; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/async.rb#441
  def init_synchronization; end

  class << self
    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/async.rb#262
    def included(base); end

    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/async.rb#250
    def validate_argc(obj, method, *args); end
  end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/async.rb#282
class Concurrent::Async::AsyncDelegator < ::Concurrent::Synchronization::LockableObject
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/async.rb#288
  def initialize(delegate); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/async.rb#305
  def method_missing(method, *args, &block); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/async.rb#330
  def perform; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/async.rb#348
  def reset_if_forked; end

  private

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/async.rb#322
  def respond_to_missing?(method, include_private = T.unsafe(nil)); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/async.rb#360
class Concurrent::Async::AwaitDelegator
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/async.rb#365
  def initialize(delegate); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/async.rb#378
  def method_missing(method, *args, &block); end

  private

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/async.rb#387
  def respond_to_missing?(method, include_private = T.unsafe(nil)); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/async.rb#269
module Concurrent::Async::ClassMethods
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/async.rb#270
  def new(*args, &block); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/atom.rb#95
class Concurrent::Atom < ::Concurrent::Synchronization::Object
  include ::Concurrent::Concern::Observable
  extend ::Concurrent::Synchronization::SafeInitialization

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atom.rb#121
  def initialize(value, opts = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/object.rb#137
  def __initialize_atomic_fields__; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atom.rb#181
  def compare_and_set(old_value, new_value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/object.rb#93
  def deref; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atom.rb#198
  def reset(new_value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atom.rb#157
  def swap(*args); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/object.rb#93
  def value; end

  private

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/object.rb#105
  def compare_and_set_value(expected, value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/object.rb#101
  def swap_value(value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/object.rb#109
  def update_value(&block); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atom.rb#216
  def valid?(new_value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/object.rb#97
  def value=(value); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/atomic_boolean.rb#120
class Concurrent::AtomicBoolean < ::Concurrent::CAtomicBoolean
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/atomic_boolean.rb#121
  def inspect; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/atomic_boolean.rb#121
  def to_s; end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/atomic_boolean.rb#82
Concurrent::AtomicBooleanImplementation = Concurrent::CAtomicBoolean

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic_reference/atomic_direct_update.rb#9
module Concurrent::AtomicDirectUpdate
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic_reference/atomic_direct_update.rb#15
  def try_update; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic_reference/atomic_direct_update.rb#24
  def try_update!; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic_reference/atomic_direct_update.rb#10
  def update; end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/atomic_fixnum.rb#137
class Concurrent::AtomicFixnum < ::Concurrent::CAtomicFixnum
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/atomic_fixnum.rb#138
  def inspect; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/atomic_fixnum.rb#138
  def to_s; end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/atomic_fixnum.rb#99
Concurrent::AtomicFixnumImplementation = Concurrent::CAtomicFixnum

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/atomic_markable_reference.rb#10
class Concurrent::AtomicMarkableReference < ::Concurrent::Synchronization::Object
  extend ::Concurrent::Synchronization::SafeInitialization

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/atomic_markable_reference.rb#15
  def initialize(value = T.unsafe(nil), mark = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/object.rb#137
  def __initialize_atomic_fields__; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/atomic_markable_reference.rb#33
  def compare_and_set(expected_val, new_val, expected_mark, new_mark); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/atomic_markable_reference.rb#33
  def compare_and_swap(expected_val, new_val, expected_mark, new_mark); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/atomic_markable_reference.rb#64
  def get; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/atomic_markable_reference.rb#78
  def mark; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/atomic_markable_reference.rb#78
  def marked?; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/atomic_markable_reference.rb#91
  def set(new_val, new_mark); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/atomic_markable_reference.rb#152
  def try_update; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/atomic_markable_reference.rb#128
  def try_update!; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/atomic_markable_reference.rb#105
  def update; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/atomic_markable_reference.rb#71
  def value; end

  private

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/object.rb#105
  def compare_and_set_reference(expected, value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/atomic_markable_reference.rb#163
  def immutable_array(*args); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/object.rb#93
  def reference; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/object.rb#97
  def reference=(value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/object.rb#101
  def swap_reference(value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/object.rb#109
  def update_reference(&block); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic_reference/numeric_cas_wrapper.rb#7
module Concurrent::AtomicNumericCompareAndSetWrapper
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic_reference/numeric_cas_wrapper.rb#10
  def compare_and_set(old_value, new_value); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/atomic_reference.rb#126
class Concurrent::AtomicReference < ::Concurrent::CAtomicReference
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/atomic_reference.rb#129
  def inspect; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/atomic_reference.rb#129
  def to_s; end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/atomic_reference.rb#18
Concurrent::AtomicReferenceImplementation = Concurrent::CAtomicReference

class Concurrent::CAtomicBoolean
  def initialize(*_arg0); end

  def false?; end
  def make_false; end
  def make_true; end
  def true?; end
  def value; end
  def value=(_arg0); end
end

class Concurrent::CAtomicFixnum
  def initialize(*_arg0); end

  def compare_and_set(_arg0, _arg1); end
  def decrement(*_arg0); end
  def down(*_arg0); end
  def increment(*_arg0); end
  def up(*_arg0); end
  def update; end
  def value; end
  def value=(_arg0); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/atomic_reference.rb#22
class Concurrent::CAtomicReference
  include ::Concurrent::AtomicDirectUpdate
  include ::Concurrent::AtomicNumericCompareAndSetWrapper

  def initialize(*_arg0); end

  def _compare_and_set(_arg0, _arg1); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic_reference/numeric_cas_wrapper.rb#10
  def compare_and_swap(old_value, new_value); end

  def get; end
  def get_and_set(_arg0); end
  def set(_arg0); end
  def swap(_arg0); end
  def value; end
  def value=(_arg0); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/set.rb#30
class Concurrent::CRubySet < ::Set
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/util/data_structures.rb#18
  def initialize(*args, &block); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/util/data_structures.rb#32
  def &(*args); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/util/data_structures.rb#32
  def +(*args); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/util/data_structures.rb#32
  def -(*args); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/util/data_structures.rb#32
  def <(*args); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/util/data_structures.rb#32
  def <<(*args); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/util/data_structures.rb#32
  def <=(*args); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/util/data_structures.rb#32
  def ==(*args); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/util/data_structures.rb#32
  def ===(*args); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/util/data_structures.rb#32
  def >(*args); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/util/data_structures.rb#32
  def >=(*args); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/util/data_structures.rb#32
  def ^(*args); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/util/data_structures.rb#32
  def add(*args); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/util/data_structures.rb#32
  def add?(*args); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/util/data_structures.rb#32
  def classify(*args); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/util/data_structures.rb#32
  def clear(*args); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/util/data_structures.rb#32
  def collect!(*args); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/util/data_structures.rb#32
  def compare_by_identity(*args); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/util/data_structures.rb#32
  def compare_by_identity?(*args); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/util/data_structures.rb#32
  def delete(*args); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/util/data_structures.rb#32
  def delete?(*args); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/util/data_structures.rb#32
  def delete_if(*args); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/util/data_structures.rb#32
  def difference(*args); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/util/data_structures.rb#32
  def disjoint?(*args); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/util/data_structures.rb#32
  def divide(*args); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/util/data_structures.rb#32
  def each(*args); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/util/data_structures.rb#32
  def empty?(*args); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/util/data_structures.rb#32
  def eql?(*args); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/util/data_structures.rb#32
  def filter!(*args); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/util/data_structures.rb#32
  def flatten(*args); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/util/data_structures.rb#32
  def flatten!(*args); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/util/data_structures.rb#32
  def flatten_merge(*args); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/util/data_structures.rb#32
  def freeze(*args); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/util/data_structures.rb#32
  def hash(*args); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/util/data_structures.rb#32
  def include?(*args); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/util/data_structures.rb#32
  def inspect(*args); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/util/data_structures.rb#32
  def intersect?(*args); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/util/data_structures.rb#32
  def intersection(*args); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/util/data_structures.rb#32
  def keep_if(*args); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/util/data_structures.rb#32
  def length(*args); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/util/data_structures.rb#32
  def map!(*args); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/util/data_structures.rb#32
  def member?(*args); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/util/data_structures.rb#32
  def merge(*args); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/util/data_structures.rb#32
  def pretty_print(*args); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/util/data_structures.rb#32
  def pretty_print_cycle(*args); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/util/data_structures.rb#32
  def proper_subset?(*args); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/util/data_structures.rb#32
  def proper_superset?(*args); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/util/data_structures.rb#32
  def reject!(*args); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/util/data_structures.rb#32
  def replace(*args); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/util/data_structures.rb#32
  def reset(*args); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/util/data_structures.rb#32
  def select!(*args); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/util/data_structures.rb#32
  def size(*args); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/util/data_structures.rb#32
  def subset?(*args); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/util/data_structures.rb#32
  def subtract(*args); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/util/data_structures.rb#32
  def superset?(*args); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/util/data_structures.rb#32
  def to_a(*args); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/util/data_structures.rb#32
  def to_s(*args); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/util/data_structures.rb#32
  def to_set(*args); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/util/data_structures.rb#32
  def union(*args); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/util/data_structures.rb#32
  def |(*args); end

  private

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/util/data_structures.rb#23
  def initialize_copy(other); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/cached_thread_pool.rb#27
class Concurrent::CachedThreadPool < ::Concurrent::ThreadPoolExecutor
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/cached_thread_pool.rb#39
  def initialize(opts = T.unsafe(nil)); end

  private

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/cached_thread_pool.rb#51
  def ns_initialize(opts); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/errors.rb#9
class Concurrent::CancelledOperationError < ::Concurrent::Error; end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#7
module Concurrent::Collection; end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/copy_on_notify_observer_set.rb#12
class Concurrent::Collection::CopyOnNotifyObserverSet < ::Concurrent::Synchronization::LockableObject
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/copy_on_notify_observer_set.rb#14
  def initialize; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/copy_on_notify_observer_set.rb#20
  def add_observer(observer = T.unsafe(nil), func = T.unsafe(nil), &block); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/copy_on_notify_observer_set.rb#55
  def count_observers; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/copy_on_notify_observer_set.rb#39
  def delete_observer(observer); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/copy_on_notify_observer_set.rb#47
  def delete_observers; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/copy_on_notify_observer_set.rb#72
  def notify_and_delete_observers(*args, &block); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/copy_on_notify_observer_set.rb#62
  def notify_observers(*args, &block); end

  protected

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/copy_on_notify_observer_set.rb#80
  def ns_initialize; end

  private

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/copy_on_notify_observer_set.rb#86
  def duplicate_and_clear_observers; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/copy_on_notify_observer_set.rb#94
  def duplicate_observers; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/copy_on_notify_observer_set.rb#98
  def notify_to(observers, *args); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/copy_on_write_observer_set.rb#11
class Concurrent::Collection::CopyOnWriteObserverSet < ::Concurrent::Synchronization::LockableObject
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/copy_on_write_observer_set.rb#13
  def initialize; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/copy_on_write_observer_set.rb#19
  def add_observer(observer = T.unsafe(nil), func = T.unsafe(nil), &block); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/copy_on_write_observer_set.rb#56
  def count_observers; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/copy_on_write_observer_set.rb#40
  def delete_observer(observer); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/copy_on_write_observer_set.rb#50
  def delete_observers; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/copy_on_write_observer_set.rb#72
  def notify_and_delete_observers(*args, &block); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/copy_on_write_observer_set.rb#63
  def notify_observers(*args, &block); end

  protected

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/copy_on_write_observer_set.rb#80
  def ns_initialize; end

  private

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/copy_on_write_observer_set.rb#102
  def clear_observers_and_return_old; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/copy_on_write_observer_set.rb#86
  def notify_to(observers, *args); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/copy_on_write_observer_set.rb#94
  def observers; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/copy_on_write_observer_set.rb#98
  def observers=(new_set); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#10
Concurrent::Collection::MapImplementation = Concurrent::Collection::MriMapBackend

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/mri_map_backend.rb#10
class Concurrent::Collection::MriMapBackend < ::Concurrent::Collection::NonConcurrentMapBackend
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/mri_map_backend.rb#12
  def initialize(options = T.unsafe(nil), &default_proc); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/mri_map_backend.rb#17
  def []=(key, value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/mri_map_backend.rb#61
  def clear; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/mri_map_backend.rb#33
  def compute(key); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/mri_map_backend.rb#21
  def compute_if_absent(key); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/mri_map_backend.rb#29
  def compute_if_present(key); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/mri_map_backend.rb#53
  def delete(key); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/mri_map_backend.rb#57
  def delete_pair(key, value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/mri_map_backend.rb#49
  def get_and_set(key, value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/mri_map_backend.rb#37
  def merge_pair(key, value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/mri_map_backend.rb#45
  def replace_if_exists(key, new_value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/mri_map_backend.rb#41
  def replace_pair(key, old_value, new_value); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#9
class Concurrent::Collection::NonConcurrentMapBackend
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#15
  def initialize(options = T.unsafe(nil), &default_proc); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#21
  def [](key); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#25
  def []=(key, value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#94
  def clear; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#59
  def compute(key); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#29
  def compute_if_absent(key); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#53
  def compute_if_present(key); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#81
  def delete(key); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#85
  def delete_pair(key, value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#99
  def each_pair; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#71
  def get_and_set(key, value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#110
  def get_or_default(key, default_value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#77
  def key?(key); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#63
  def merge_pair(key, value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#46
  def replace_if_exists(key, new_value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#37
  def replace_pair(key, old_value, new_value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#106
  def size; end

  private

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#130
  def dupped_backend; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#124
  def initialize_copy(other); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#134
  def pair?(key, expected_value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#116
  def set_backend(default_proc); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#138
  def store_computed_value(key, new_value); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/non_concurrent_priority_queue.rb#50
class Concurrent::Collection::NonConcurrentPriorityQueue < ::Concurrent::Collection::RubyNonConcurrentPriorityQueue
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/ruby_non_concurrent_priority_queue.rb#78
  def <<(item); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/ruby_non_concurrent_priority_queue.rb#65
  def deq; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/ruby_non_concurrent_priority_queue.rb#78
  def enq(item); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/ruby_non_concurrent_priority_queue.rb#48
  def has_priority?(item); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/ruby_non_concurrent_priority_queue.rb#65
  def shift; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/ruby_non_concurrent_priority_queue.rb#54
  def size; end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/non_concurrent_priority_queue.rb#10
Concurrent::Collection::NonConcurrentPriorityQueueImplementation = Concurrent::Collection::RubyNonConcurrentPriorityQueue

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/ruby_non_concurrent_priority_queue.rb#8
class Concurrent::Collection::RubyNonConcurrentPriorityQueue
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/ruby_non_concurrent_priority_queue.rb#11
  def initialize(opts = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/ruby_non_concurrent_priority_queue.rb#78
  def <<(item); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/ruby_non_concurrent_priority_queue.rb#18
  def clear; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/ruby_non_concurrent_priority_queue.rb#25
  def delete(item); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/ruby_non_concurrent_priority_queue.rb#65
  def deq; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/ruby_non_concurrent_priority_queue.rb#43
  def empty?; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/ruby_non_concurrent_priority_queue.rb#78
  def enq(item); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/ruby_non_concurrent_priority_queue.rb#48
  def has_priority?(item); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/ruby_non_concurrent_priority_queue.rb#48
  def include?(item); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/ruby_non_concurrent_priority_queue.rb#54
  def length; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/ruby_non_concurrent_priority_queue.rb#60
  def peek; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/ruby_non_concurrent_priority_queue.rb#65
  def pop; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/ruby_non_concurrent_priority_queue.rb#78
  def push(item); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/ruby_non_concurrent_priority_queue.rb#65
  def shift; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/ruby_non_concurrent_priority_queue.rb#54
  def size; end

  private

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/ruby_non_concurrent_priority_queue.rb#119
  def ordered?(x, y); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/ruby_non_concurrent_priority_queue.rb#128
  def sink(k); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/ruby_non_concurrent_priority_queue.rb#103
  def swap(x, y); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/ruby_non_concurrent_priority_queue.rb#147
  def swim(k); end

  class << self
    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/ruby_non_concurrent_priority_queue.rb#89
    def from_list(list, opts = T.unsafe(nil)); end
  end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/dereferenceable.rb#2
module Concurrent::Concern; end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/deprecation.rb#8
module Concurrent::Concern::Deprecation
  include ::Logger::Severity
  include ::Concurrent::Concern::Logging
  extend ::Logger::Severity
  extend ::Concurrent::Concern::Logging
  extend ::Concurrent::Concern::Deprecation

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/deprecation.rb#12
  def deprecated(message, strip = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/deprecation.rb#27
  def deprecated_method(old_name, new_name); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/dereferenceable.rb#11
module Concurrent::Concern::Dereferenceable
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/dereferenceable.rb#21
  def deref; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/dereferenceable.rb#21
  def value; end

  protected

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/dereferenceable.rb#63
  def apply_deref_options(value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/dereferenceable.rb#54
  def ns_set_deref_options(opts); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/dereferenceable.rb#48
  def set_deref_options(opts = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/dereferenceable.rb#31
  def value=(value); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/logging.rb#10
module Concurrent::Concern::Logging
  include ::Logger::Severity

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/logging.rb#18
  def log(level, progname, message = T.unsafe(nil), &block); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/obligation.rb#10
module Concurrent::Concern::Obligation
  include ::Concurrent::Concern::Dereferenceable

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/obligation.rb#49
  def complete?; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/obligation.rb#126
  def exception(*args); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/obligation.rb#20
  def fulfilled?; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/obligation.rb#56
  def incomplete?; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/obligation.rb#86
  def no_error!(timeout = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/obligation.rb#35
  def pending?; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/obligation.rb#20
  def realized?; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/obligation.rb#119
  def reason; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/obligation.rb#28
  def rejected?; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/obligation.rb#110
  def state; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/obligation.rb#42
  def unscheduled?; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/obligation.rb#65
  def value(timeout = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/obligation.rb#98
  def value!(timeout = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/obligation.rb#74
  def wait(timeout = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/obligation.rb#86
  def wait!(timeout = T.unsafe(nil)); end

  protected

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/obligation.rb#174
  def compare_and_set_state(next_state, *expected_current); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/obligation.rb#145
  def event; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/obligation.rb#134
  def get_arguments_from(opts = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/obligation.rb#190
  def if_state(*expected_states); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/obligation.rb#139
  def init_obligation; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/obligation.rb#210
  def ns_check_state?(expected); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/obligation.rb#215
  def ns_set_state(value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/obligation.rb#150
  def set_state(success, value, reason); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/obligation.rb#161
  def state=(value); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/observable.rb#50
module Concurrent::Concern::Observable
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/observable.rb#61
  def add_observer(observer = T.unsafe(nil), func = T.unsafe(nil), &block); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/observable.rb#101
  def count_observers; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/observable.rb#82
  def delete_observer(observer); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/observable.rb#91
  def delete_observers; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/observable.rb#70
  def with_observer(observer = T.unsafe(nil), func = T.unsafe(nil), &block); end

  protected

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/observable.rb#107
  def observers; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/observable.rb#107
  def observers=(_arg0); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/errors.rb#71
class Concurrent::ConcurrentUpdateError < ::ThreadError; end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/errors.rb#72
Concurrent::ConcurrentUpdateError::CONC_UP_ERR_BACKTRACE = T.let(T.unsafe(nil), Array)

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/errors.rb#6
class Concurrent::ConfigurationError < ::Concurrent::Error; end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/count_down_latch.rb#98
class Concurrent::CountDownLatch < ::Concurrent::MutexCountDownLatch; end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/count_down_latch.rb#56
Concurrent::CountDownLatchImplementation = Concurrent::MutexCountDownLatch

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/cyclic_barrier.rb#27
class Concurrent::CyclicBarrier < ::Concurrent::Synchronization::LockableObject
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/cyclic_barrier.rb#40
  def initialize(parties, &block); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/cyclic_barrier.rb#105
  def broken?; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/cyclic_barrier.rb#54
  def number_waiting; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/cyclic_barrier.rb#49
  def parties; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/cyclic_barrier.rb#95
  def reset; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/cyclic_barrier.rb#66
  def wait(timeout = T.unsafe(nil)); end

  protected

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/cyclic_barrier.rb#111
  def ns_generation_done(generation, status, continue = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/cyclic_barrier.rb#122
  def ns_initialize(parties, &block); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/cyclic_barrier.rb#117
  def ns_next_generation; end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/cyclic_barrier.rb#30
class Concurrent::CyclicBarrier::Generation < ::Struct
  def status; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/cyclic_barrier.rb#30
  def status=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/delay.rb#44
class Concurrent::Delay < ::Concurrent::Synchronization::LockableObject
  include ::Concurrent::Concern::Dereferenceable
  include ::Concurrent::Concern::Obligation

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/delay.rb#62
  def initialize(opts = T.unsafe(nil), &block); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/delay.rb#146
  def reconfigure(&block); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/delay.rb#77
  def value(timeout = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/delay.rb#113
  def value!(timeout = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/delay.rb#132
  def wait(timeout = T.unsafe(nil)); end

  protected

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/delay.rb#160
  def ns_initialize(opts, &block); end

  private

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/delay.rb#173
  def execute_task_once; end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/dataflow.rb#7
class Concurrent::DependencyCounter
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/dataflow.rb#9
  def initialize(count, &block); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/dataflow.rb#14
  def update(time, value, reason); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/errors.rb#3
class Concurrent::Error < ::StandardError; end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/event.rb#36
class Concurrent::Event < ::Concurrent::Synchronization::LockableObject
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/event.rb#40
  def initialize; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/event.rb#68
  def reset; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/event.rb#56
  def set; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/event.rb#48
  def set?; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/event.rb#60
  def try?; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/event.rb#83
  def wait(timeout = T.unsafe(nil)); end

  protected

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/event.rb#104
  def ns_initialize; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/event.rb#96
  def ns_set; end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/exchanger.rb#336
class Concurrent::Exchanger < ::Concurrent::RubyExchanger; end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/exchanger.rb#327
Concurrent::ExchangerImplementation = Concurrent::RubyExchanger

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/executor_service.rb#157
module Concurrent::ExecutorService
  include ::Logger::Severity
  include ::Concurrent::Concern::Logging

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/executor_service.rb#166
  def <<(task); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/executor_service.rb#174
  def can_overflow?; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/executor_service.rb#161
  def post(*args, &task); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/executor_service.rb#181
  def serialized?; end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/fiber_local_var.rb#41
class Concurrent::FiberLocalVar
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/fiber_local_var.rb#49
  def initialize(default = T.unsafe(nil), &default_block); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/fiber_local_var.rb#86
  def bind(value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/fiber_local_var.rb#68
  def value; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/fiber_local_var.rb#76
  def value=(value); end

  protected

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/fiber_local_var.rb#101
  def default; end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/fiber_local_var.rb#42
Concurrent::FiberLocalVar::LOCALS = T.let(T.unsafe(nil), Concurrent::FiberLocals)

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/locals.rb#166
class Concurrent::FiberLocals < ::Concurrent::AbstractLocals
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/locals.rb#167
  def locals; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/locals.rb#171
  def locals!; end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/fixed_thread_pool.rb#197
class Concurrent::FixedThreadPool < ::Concurrent::ThreadPoolExecutor
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/fixed_thread_pool.rb#211
  def initialize(num_threads, opts = T.unsafe(nil)); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/future.rb#21
class Concurrent::Future < ::Concurrent::IVar
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/future.rb#33
  def initialize(opts = T.unsafe(nil), &block); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/future.rb#99
  def cancel; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/future.rb#111
  def cancelled?; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/future.rb#53
  def execute; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/future.rb#82
  def set(value = T.unsafe(nil), &block); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/future.rb#121
  def wait_or_cancel(timeout); end

  protected

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/future.rb#133
  def ns_initialize(value, opts); end

  class << self
    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/future.rb#77
    def execute(opts = T.unsafe(nil), &block); end
  end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/configuration.rb#18
Concurrent::GLOBAL_FAST_EXECUTOR = T.let(T.unsafe(nil), Concurrent::Delay)

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/configuration.rb#30
Concurrent::GLOBAL_IMMEDIATE_EXECUTOR = T.let(T.unsafe(nil), Concurrent::ImmediateExecutor)

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/configuration.rb#22
Concurrent::GLOBAL_IO_EXECUTOR = T.let(T.unsafe(nil), Concurrent::Delay)

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/logging.rb#106
Concurrent::GLOBAL_LOGGER = T.let(T.unsafe(nil), Concurrent::AtomicReference)

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/configuration.rb#26
Concurrent::GLOBAL_TIMER_SET = T.let(T.unsafe(nil), Concurrent::Delay)

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/hash.rb#47
class Concurrent::Hash < ::Hash; end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/hash.rb#16
Concurrent::HashImplementation = Hash

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/ivar.rb#48
class Concurrent::IVar < ::Concurrent::Synchronization::LockableObject
  include ::Concurrent::Concern::Dereferenceable
  include ::Concurrent::Concern::Obligation
  include ::Concurrent::Concern::Observable

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/ivar.rb#62
  def initialize(value = T.unsafe(nil), opts = T.unsafe(nil), &block); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/ivar.rb#81
  def add_observer(observer = T.unsafe(nil), func = T.unsafe(nil), &block); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/ivar.rb#135
  def fail(reason = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/ivar.rb#113
  def set(value = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/ivar.rb#145
  def try_set(value = T.unsafe(nil), &block); end

  protected

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/ivar.rb#202
  def check_for_block_or_value!(block_given, value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/ivar.rb#177
  def complete(success, value, reason); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/ivar.rb#184
  def complete_without_notification(success, value, reason); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/ivar.rb#190
  def notify_observers(value, reason); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/ivar.rb#195
  def ns_complete_without_notification(success, value, reason); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/ivar.rb#155
  def ns_initialize(value, opts); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/ivar.rb#168
  def safe_execute(task, args = T.unsafe(nil)); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/errors.rb#20
class Concurrent::IllegalOperationError < ::Concurrent::Error; end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/immediate_executor.rb#17
class Concurrent::ImmediateExecutor < ::Concurrent::AbstractExecutorService
  include ::Concurrent::SerialExecutorService

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/immediate_executor.rb#21
  def initialize; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/immediate_executor.rb#34
  def <<(task); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/immediate_executor.rb#55
  def kill; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/immediate_executor.rb#26
  def post(*args, &task); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/immediate_executor.rb#40
  def running?; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/immediate_executor.rb#55
  def shutdown; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/immediate_executor.rb#50
  def shutdown?; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/immediate_executor.rb#45
  def shuttingdown?; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/immediate_executor.rb#62
  def wait_for_termination(timeout = T.unsafe(nil)); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/errors.rb#16
class Concurrent::ImmutabilityError < ::Concurrent::Error; end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/immutable_struct.rb#9
module Concurrent::ImmutableStruct
  include ::Concurrent::Synchronization::AbstractStruct

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/immutable_struct.rb#51
  def ==(other); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/immutable_struct.rb#46
  def [](member); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/immutable_struct.rb#56
  def each(&block); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/immutable_struct.rb#62
  def each_pair(&block); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/immutable_struct.rb#29
  def inspect; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/immutable_struct.rb#36
  def merge(other, &block); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/immutable_struct.rb#68
  def select(&block); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/immutable_struct.rb#17
  def to_a; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/immutable_struct.rb#41
  def to_h; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/immutable_struct.rb#29
  def to_s; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/immutable_struct.rb#17
  def values; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/immutable_struct.rb#24
  def values_at(*indexes); end

  private

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/immutable_struct.rb#76
  def initialize_copy(original); end

  class << self
    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/immutable_struct.rb#12
    def included(base); end

    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/immutable_struct.rb#82
    def new(*args, &block); end
  end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/immutable_struct.rb#92
Concurrent::ImmutableStruct::FACTORY = T.let(T.unsafe(nil), T.untyped)

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/indirect_immediate_executor.rb#20
class Concurrent::IndirectImmediateExecutor < ::Concurrent::ImmediateExecutor
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/indirect_immediate_executor.rb#21
  def initialize; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/indirect_immediate_executor.rb#27
  def post(*args, &task); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/errors.rb#24
class Concurrent::InitializationError < ::Concurrent::Error; end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/errors.rb#13
class Concurrent::LifecycleError < ::Concurrent::Error; end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/lock_free_stack.rb#6
class Concurrent::LockFreeStack < ::Concurrent::Synchronization::Object
  include ::Enumerable
  extend ::Concurrent::Synchronization::SafeInitialization

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/lock_free_stack.rb#51
  def initialize(head = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/object.rb#137
  def __initialize_atomic_fields__; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/lock_free_stack.rb#118
  def clear; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/lock_free_stack.rb#142
  def clear_each(&block); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/lock_free_stack.rb#128
  def clear_if(head); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/lock_free_stack.rb#99
  def compare_and_clear(head); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/lock_free_stack.rb#85
  def compare_and_pop(head); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/lock_free_stack.rb#65
  def compare_and_push(head, value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/lock_free_stack.rb#107
  def each(head = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/lock_free_stack.rb#58
  def empty?(head = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/lock_free_stack.rb#154
  def inspect; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/lock_free_stack.rb#79
  def peek; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/lock_free_stack.rb#90
  def pop; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/lock_free_stack.rb#71
  def push(value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/lock_free_stack.rb#135
  def replace_if(head, new_head); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/lock_free_stack.rb#154
  def to_s; end

  private

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/object.rb#105
  def compare_and_set_head(expected, value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/object.rb#93
  def head; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/object.rb#97
  def head=(value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/object.rb#101
  def swap_head(value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/object.rb#109
  def update_head(&block); end

  class << self
    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/lock_free_stack.rb#41
    def of1(value); end

    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/lock_free_stack.rb#46
    def of2(value1, value2); end
  end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/lock_free_stack.rb#32
Concurrent::LockFreeStack::EMPTY = T.let(T.unsafe(nil), Concurrent::LockFreeStack::Node)

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/lock_free_stack.rb#10
class Concurrent::LockFreeStack::Node
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/lock_free_stack.rb#23
  def initialize(value, next_node); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/lock_free_stack.rb#14
  def next_node; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/lock_free_stack.rb#17
  def value; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/lock_free_stack.rb#21
  def value=(_arg0); end

  class << self
    def [](*_arg0); end
  end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/lock_local_var.rb#19
Concurrent::LockLocalVar = Concurrent::ThreadLocalVar

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/mvar.rb#38
class Concurrent::MVar < ::Concurrent::Synchronization::Object
  include ::Concurrent::Concern::Dereferenceable
  extend ::Concurrent::Synchronization::SafeInitialization

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/mvar.rb#54
  def initialize(value = T.unsafe(nil), opts = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/mvar.rb#86
  def borrow(timeout = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/mvar.rb#195
  def empty?; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/mvar.rb#200
  def full?; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/mvar.rb#123
  def modify(timeout = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/mvar.rb#179
  def modify!; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/mvar.rb#103
  def put(value, timeout = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/mvar.rb#169
  def set!(value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/mvar.rb#66
  def take(timeout = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/mvar.rb#156
  def try_put!(value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/mvar.rb#142
  def try_take!; end

  protected

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/mvar.rb#206
  def synchronize(&block); end

  private

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/mvar.rb#212
  def unlocked_empty?; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/mvar.rb#216
  def unlocked_full?; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/mvar.rb#224
  def wait_for_empty(timeout); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/mvar.rb#220
  def wait_for_full(timeout); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/mvar.rb#228
  def wait_while(condition, timeout); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/mvar.rb#43
Concurrent::MVar::EMPTY = T.let(T.unsafe(nil), Object)

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/mvar.rb#47
Concurrent::MVar::TIMEOUT = T.let(T.unsafe(nil), Object)

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#39
class Concurrent::Map < ::Concurrent::Collection::MriMapBackend
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#274
  def each; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#255
  def each_key; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#274
  def each_pair; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#264
  def each_value; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#291
  def empty?; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#183
  def fetch(key, default_value = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#205
  def fetch_or_store(key, default_value = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/non_concurrent_map_backend.rb#21
  def get(key); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#321
  def inspect; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#284
  def key(value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#236
  def keys; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#305
  def marshal_dump; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#313
  def marshal_load(hash); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/collection/map/mri_map_backend.rb#17
  def put(key, value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#215
  def put_if_absent(key, value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#227
  def value?(value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#244
  def values; end

  private

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#331
  def initialize_copy(other); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#336
  def populate_from(hash); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#327
  def raise_fetch_no_key; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/map.rb#341
  def validate_options_hash!(options); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/errors.rb#29
class Concurrent::MaxRestartFrequencyError < ::Concurrent::Error; end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/maybe.rb#104
class Concurrent::Maybe < ::Concurrent::Synchronization::Object
  include ::Comparable
  extend ::Concurrent::Synchronization::SafeInitialization

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/maybe.rb#224
  def initialize(just, nothing); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/maybe.rb#199
  def <=>(other); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/maybe.rb#176
  def fulfilled?; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/maybe.rb#114
  def just; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/maybe.rb#176
  def just?; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/maybe.rb#117
  def nothing; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/maybe.rb#184
  def nothing?; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/maybe.rb#210
  def or(other); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/maybe.rb#117
  def reason; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/maybe.rb#184
  def rejected?; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/maybe.rb#114
  def value; end

  class << self
    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/maybe.rb#137
    def from(*args); end

    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/maybe.rb#152
    def just(value); end

    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/maybe.rb#164
    def nothing(error = T.unsafe(nil)); end
  end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/maybe.rb#111
Concurrent::Maybe::NONE = T.let(T.unsafe(nil), Object)

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/errors.rb#33
class Concurrent::MultipleAssignmentError < ::Concurrent::Error
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/errors.rb#36
  def initialize(message = T.unsafe(nil), inspection_data = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/errors.rb#41
  def inspect; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/errors.rb#34
  def inspection_data; end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/errors.rb#58
class Concurrent::MultipleErrors < ::Concurrent::Error
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/errors.rb#61
  def initialize(errors, message = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/errors.rb#59
  def errors; end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/mutable_struct.rb#10
module Concurrent::MutableStruct
  include ::Concurrent::Synchronization::AbstractStruct

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/mutable_struct.rb#128
  def ==(other); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/mutable_struct.rb#118
  def [](member); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/mutable_struct.rb#185
  def []=(member, value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/mutable_struct.rb#139
  def each(&block); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/mutable_struct.rb#152
  def each_pair(&block); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/mutable_struct.rb#72
  def inspect; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/mutable_struct.rb#94
  def merge(other, &block); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/mutable_struct.rb#167
  def select(&block); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/mutable_struct.rb#51
  def to_a; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/mutable_struct.rb#103
  def to_h; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/mutable_struct.rb#72
  def to_s; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/mutable_struct.rb#51
  def values; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/mutable_struct.rb#63
  def values_at(*indexes); end

  private

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/mutable_struct.rb#202
  def initialize_copy(original); end

  class << self
    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/mutable_struct.rb#210
    def new(*args, &block); end
  end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/mutable_struct.rb#220
Concurrent::MutableStruct::FACTORY = T.let(T.unsafe(nil), T.untyped)

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_atomic_boolean.rb#8
class Concurrent::MutexAtomicBoolean
  extend ::Concurrent::Synchronization::SafeInitialization

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_atomic_boolean.rb#12
  def initialize(initial = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_atomic_boolean.rb#34
  def false?; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_atomic_boolean.rb#44
  def make_false; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_atomic_boolean.rb#39
  def make_true; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_atomic_boolean.rb#29
  def true?; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_atomic_boolean.rb#19
  def value; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_atomic_boolean.rb#24
  def value=(value); end

  protected

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_atomic_boolean.rb#51
  def synchronize; end

  private

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_atomic_boolean.rb#62
  def ns_make_value(value); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_atomic_fixnum.rb#9
class Concurrent::MutexAtomicFixnum
  extend ::Concurrent::Synchronization::SafeInitialization

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_atomic_fixnum.rb#13
  def initialize(initial = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_atomic_fixnum.rb#44
  def compare_and_set(expect, update); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_atomic_fixnum.rb#37
  def decrement(delta = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_atomic_fixnum.rb#37
  def down(delta = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_atomic_fixnum.rb#30
  def increment(delta = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_atomic_fixnum.rb#30
  def up(delta = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_atomic_fixnum.rb#56
  def update; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_atomic_fixnum.rb#20
  def value; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_atomic_fixnum.rb#25
  def value=(value); end

  protected

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_atomic_fixnum.rb#65
  def synchronize; end

  private

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_atomic_fixnum.rb#76
  def ns_set(value); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic_reference/mutex_atomic.rb#9
class Concurrent::MutexAtomicReference
  include ::Concurrent::AtomicDirectUpdate
  include ::Concurrent::AtomicNumericCompareAndSetWrapper
  extend ::Concurrent::Synchronization::SafeInitialization

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic_reference/mutex_atomic.rb#16
  def initialize(value = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic_reference/mutex_atomic.rb#45
  def _compare_and_set(old_value, new_value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic_reference/numeric_cas_wrapper.rb#10
  def compare_and_swap(old_value, new_value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic_reference/mutex_atomic.rb#23
  def get; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic_reference/mutex_atomic.rb#35
  def get_and_set(new_value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic_reference/mutex_atomic.rb#29
  def set(new_value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic_reference/mutex_atomic.rb#35
  def swap(new_value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic_reference/mutex_atomic.rb#23
  def value; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic_reference/mutex_atomic.rb#29
  def value=(new_value); end

  protected

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic_reference/mutex_atomic.rb#59
  def synchronize; end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_count_down_latch.rb#9
class Concurrent::MutexCountDownLatch < ::Concurrent::Synchronization::LockableObject
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_count_down_latch.rb#12
  def initialize(count = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_count_down_latch.rb#34
  def count; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_count_down_latch.rb#26
  def count_down; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_count_down_latch.rb#21
  def wait(timeout = T.unsafe(nil)); end

  protected

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_count_down_latch.rb#40
  def ns_initialize(count); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_semaphore.rb#9
class Concurrent::MutexSemaphore < ::Concurrent::Synchronization::LockableObject
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_semaphore.rb#12
  def initialize(count); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_semaphore.rb#20
  def acquire(permits = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_semaphore.rb#38
  def available_permits; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_semaphore.rb#47
  def drain_permits; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_semaphore.rb#99
  def reduce_permits(reduction); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_semaphore.rb#77
  def release(permits = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_semaphore.rb#54
  def try_acquire(permits = T.unsafe(nil), timeout = T.unsafe(nil)); end

  protected

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_semaphore.rb#110
  def ns_initialize(count); end

  private

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_semaphore.rb#117
  def try_acquire_now(permits); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/mutex_semaphore.rb#127
  def try_acquire_timed(permits, timeout); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/constants.rb#6
Concurrent::NULL = T.let(T.unsafe(nil), Object)

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/concern/logging.rb#103
Concurrent::NULL_LOGGER = T.let(T.unsafe(nil), Proc)

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/options.rb#6
module Concurrent::Options
  class << self
    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/options.rb#27
    def executor(executor_identifier); end

    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/options.rb#19
    def executor_from_options(opts = T.unsafe(nil)); end
  end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/promise.rb#190
class Concurrent::Promise < ::Concurrent::IVar
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promise.rb#210
  def initialize(opts = T.unsafe(nil), &block); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promise.rb#360
  def catch(&block); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promise.rb#246
  def execute; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promise.rb#278
  def fail(reason = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promise.rb#375
  def flat_map(&block); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promise.rb#360
  def on_error(&block); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promise.rb#349
  def on_success(&block); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promise.rb#360
  def rescue(&block); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promise.rb#262
  def set(value = T.unsafe(nil), &block); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promise.rb#314
  def then(*args, &block); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promise.rb#440
  def zip(*others); end

  protected

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promise.rb#551
  def complete(success, value, reason); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promise.rb#545
  def notify_child(child); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promise.rb#481
  def ns_initialize(value, opts); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promise.rb#533
  def on_fulfill(result); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promise.rb#539
  def on_reject(reason); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promise.rb#562
  def realize(task); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promise.rb#528
  def root?; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promise.rb#520
  def set_pending; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promise.rb#570
  def set_state!(success, value, reason); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promise.rb#576
  def synchronized_set_state!(success, value, reason); end

  class << self
    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promise.rb#505
    def aggregate(method, *promises); end

    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promise.rb#464
    def all?(*promises); end

    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promise.rb#475
    def any?(*promises); end

    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promise.rb#296
    def execute(opts = T.unsafe(nil), &block); end

    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promise.rb#224
    def fulfill(value, opts = T.unsafe(nil)); end

    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promise.rb#237
    def reject(reason, opts = T.unsafe(nil)); end

    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promise.rb#409
    def zip(*promises); end
  end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/promise.rb#11
class Concurrent::PromiseExecutionError < ::StandardError; end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#12
module Concurrent::Promises
  extend ::Concurrent::Promises::FactoryMethods::Configuration
  extend ::Concurrent::Promises::FactoryMethods
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#2037
class Concurrent::Promises::AbstractAnyPromise < ::Concurrent::Promises::BlockedPromise; end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#512
class Concurrent::Promises::AbstractEventFuture < ::Concurrent::Synchronization::Object
  include ::Concurrent::Promises::InternalStates
  extend ::Concurrent::Synchronization::SafeInitialization

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#521
  def initialize(promise, default_executor); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/object.rb#137
  def __initialize_atomic_fields__; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#737
  def add_callback_clear_delayed_node(node); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#732
  def add_callback_notify_blocked(promise, index); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#701
  def blocks; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#709
  def callbacks; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#595
  def chain(*args, &task); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#613
  def chain_on(executor, *args, &task); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#628
  def chain_resolvable(resolvable); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#589
  def default_executor; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#618
  def inspect; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/object.rb#93
  def internal_state; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#636
  def on_resolution(*args, &callback); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#654
  def on_resolution!(*args, &callback); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#672
  def on_resolution_using(executor, *args, &callback); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#548
  def pending?; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#715
  def promise; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#687
  def resolve_with(state, raise_on_reassign = T.unsafe(nil), reserved = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#554
  def resolved?; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#542
  def state; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#628
  def tangle(resolvable); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#618
  def to_s; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#561
  def touch; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#721
  def touched?; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#577
  def wait(timeout = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#727
  def waiting_threads; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#682
  def with_default_executor(executor); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#742
  def with_hidden_resolvable; end

  private

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#749
  def add_callback(method, *args); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#802
  def async_callback_on_resolution(state, executor, args, callback); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#786
  def call_callback(method, state, args); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#790
  def call_callbacks(state); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#762
  def callback_clear_delayed_node(state, node); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#808
  def callback_notify_blocked(state, promise, index); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/object.rb#105
  def compare_and_set_internal_state(expected, value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/object.rb#97
  def internal_state=(value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/object.rb#101
  def swap_internal_state(value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/object.rb#109
  def update_internal_state(&block); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#767
  def wait_until_resolved(timeout); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#798
  def with_async(executor, *args, &block); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1786
class Concurrent::Promises::AbstractFlatPromise < ::Concurrent::Promises::BlockedPromise
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1788
  def initialize(delayed_because, blockers_count, event_or_future); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1798
  def touch; end

  private

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1818
  def add_delayed_of(future); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1810
  def on_resolvable(resolved_future, index); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1814
  def resolvable?(countdown, future, index); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1806
  def touched?; end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1539
class Concurrent::Promises::AbstractPromise < ::Concurrent::Synchronization::Object
  include ::Concurrent::Promises::InternalStates
  extend ::Concurrent::Synchronization::SafeInitialization

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1543
  def initialize(future); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1554
  def default_executor; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1571
  def delayed_because; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1548
  def event; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1548
  def future; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1565
  def inspect; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1558
  def state; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1565
  def to_s; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1562
  def touch; end

  private

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1582
  def evaluate_to(*args, block); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1577
  def resolve_with(new_state, raise_on_reassign = T.unsafe(nil)); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#2074
class Concurrent::Promises::AnyFulfilledFuturePromise < ::Concurrent::Promises::AnyResolvedFuturePromise
  private

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#2078
  def resolvable?(countdown, event_or_future, index); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#2040
class Concurrent::Promises::AnyResolvedEventPromise < ::Concurrent::Promises::AbstractAnyPromise
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#2044
  def initialize(delayed, blockers_count, default_executor); end

  private

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#2052
  def on_resolvable(resolved_future, index); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#2048
  def resolvable?(countdown, future, index); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#2057
class Concurrent::Promises::AnyResolvedFuturePromise < ::Concurrent::Promises::AbstractAnyPromise
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#2061
  def initialize(delayed, blockers_count, default_executor); end

  private

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#2069
  def on_resolvable(resolved_future, index); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#2065
  def resolvable?(countdown, future, index); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1609
class Concurrent::Promises::BlockedPromise < ::Concurrent::Promises::InnerPromise
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1651
  def initialize(delayed, blockers_count, future); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1673
  def blocked_by; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1664
  def delayed_because; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1657
  def on_blocker_resolution(future, index); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1668
  def touch; end

  private

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1681
  def clear_and_propagate_touch(stack_or_element = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1700
  def on_resolvable(resolved_future, index); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1696
  def process_on_blocker_resolution(future, index); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1692
  def resolvable?(countdown, future, index); end

  class << self
    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1642
    def add_delayed(delayed1, delayed2); end

    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1635
    def new_blocked_by(blockers, *args, &block); end

    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1613
    def new_blocked_by1(blocker, *args, &block); end

    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1620
    def new_blocked_by2(blocker1, blocker2, *args, &block); end
  end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1706
class Concurrent::Promises::BlockedTaskPromise < ::Concurrent::Promises::BlockedPromise
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1707
  def initialize(delayed, blockers_count, default_executor, executor, args, &task); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1715
  def executor; end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1756
class Concurrent::Promises::ChainPromise < ::Concurrent::Promises::BlockedTaskPromise
  private

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1759
  def on_resolvable(resolved_future, index); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#2085
class Concurrent::Promises::DelayPromise < ::Concurrent::Promises::InnerPromise
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#2087
  def initialize(default_executor); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#2098
  def delayed_because; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#2094
  def touch; end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#816
class Concurrent::Promises::Event < ::Concurrent::Promises::AbstractEventFuture
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#829
  def &(other); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#843
  def any(event_or_future); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#853
  def delay; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#865
  def schedule(intended_time); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#595
  def then(*args, &task); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#883
  def to_event; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#875
  def to_future; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#889
  def with_default_executor(executor); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#829
  def zip(other); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#843
  def |(event_or_future); end

  private

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#900
  def callback_on_resolution(state, args, callback); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#895
  def rejected_resolution(raise_on_reassign, state); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1962
class Concurrent::Promises::EventWrapperPromise < ::Concurrent::Promises::BlockedPromise
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1963
  def initialize(delayed, blockers_count, default_executor); end

  private

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1969
  def on_resolvable(resolved_future, index); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#45
module Concurrent::Promises::FactoryMethods
  include ::Concurrent::Promises::FactoryMethods::Configuration
  extend ::Concurrent::ReInclude
  extend ::Concurrent::Promises::FactoryMethods
  extend ::Concurrent::Promises::FactoryMethods::Configuration

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#277
  def any(*futures_and_or_events); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#318
  def any_event(*futures_and_or_events); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#328
  def any_event_on(default_executor, *futures_and_or_events); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#299
  def any_fulfilled_future(*futures_and_or_events); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#312
  def any_fulfilled_future_on(default_executor, *futures_and_or_events); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#277
  def any_resolved_future(*futures_and_or_events); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#293
  def any_resolved_future_on(default_executor, *futures_and_or_events); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#189
  def delay(*args, &task); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#206
  def delay_on(default_executor, *args, &task); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#126
  def fulfilled_future(value, default_executor = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#93
  def future(*args, &task); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#105
  def future_on(default_executor, *args, &task); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#173
  def make_future(argument = T.unsafe(nil), default_executor = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#135
  def rejected_future(reason, default_executor = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#62
  def resolvable_event; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#71
  def resolvable_event_on(default_executor = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#77
  def resolvable_future; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#87
  def resolvable_future_on(default_executor = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#143
  def resolved_event(default_executor = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#117
  def resolved_future(fulfilled, value, reason, default_executor = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#213
  def schedule(intended_time, *args, &task); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#232
  def schedule_on(default_executor, intended_time, *args, &task); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#239
  def zip(*futures_and_or_events); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#261
  def zip_events(*futures_and_or_events); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#271
  def zip_events_on(default_executor, *futures_and_or_events); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#239
  def zip_futures(*futures_and_or_events); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#253
  def zip_futures_on(default_executor, *futures_and_or_events); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#49
module Concurrent::Promises::FactoryMethods::Configuration
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#53
  def default_executor; end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1830
class Concurrent::Promises::FlatEventPromise < ::Concurrent::Promises::AbstractFlatPromise
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1834
  def initialize(delayed, blockers_count, default_executor); end

  private

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1838
  def process_on_blocker_resolution(future, index); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1863
class Concurrent::Promises::FlatFuturePromise < ::Concurrent::Promises::AbstractFlatPromise
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1867
  def initialize(delayed, blockers_count, levels, default_executor); end

  private

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1874
  def process_on_blocker_resolution(future, index); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#907
class Concurrent::Promises::Future < ::Concurrent::Promises::AbstractEventFuture
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1060
  def &(other); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1075
  def any(event_or_future); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1205
  def apply(args, block); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1085
  def delay; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1003
  def exception(*args); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1110
  def flat(level = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1120
  def flat_event; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1110
  def flat_future(level = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#911
  def fulfilled?; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1225
  def inspect; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1126
  def on_fulfillment(*args, &callback); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1137
  def on_fulfillment!(*args, &callback); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1149
  def on_fulfillment_using(executor, *args, &callback); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1155
  def on_rejection(*args, &callback); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1166
  def on_rejection!(*args, &callback); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1178
  def on_rejection_using(executor, *args, &callback); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#956
  def reason(timeout = T.unsafe(nil), timeout_value = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#918
  def rejected?; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1042
  def rescue(*args, &task); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1054
  def rescue_on(executor, *args, &task); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#971
  def result(timeout = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1200
  def run(run_test = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1092
  def schedule(intended_time); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1024
  def then(*args, &task); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1036
  def then_on(executor, *args, &task); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1212
  def to_event; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1220
  def to_future; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1225
  def to_s; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#940
  def value(timeout = T.unsafe(nil), timeout_value = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#987
  def value!(timeout = T.unsafe(nil), timeout_value = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#977
  def wait!(timeout = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1101
  def with_default_executor(executor); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1060
  def zip(other); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1075
  def |(event_or_future); end

  private

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1262
  def async_callback_on_fulfillment(state, executor, args, callback); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1268
  def async_callback_on_rejection(state, executor, args, callback); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1274
  def callback_on_fulfillment(state, args, callback); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1278
  def callback_on_rejection(state, args, callback); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1282
  def callback_on_resolution(state, args, callback); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1241
  def rejected_resolution(raise_on_reassign, state); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1237
  def run_test(v); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1256
  def wait_until_resolved!(timeout = T.unsafe(nil)); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1974
class Concurrent::Promises::FutureWrapperPromise < ::Concurrent::Promises::BlockedPromise
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1975
  def initialize(delayed, blockers_count, default_executor); end

  private

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1981
  def on_resolvable(resolved_future, index); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1773
class Concurrent::Promises::ImmediateEventPromise < ::Concurrent::Promises::InnerPromise
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1774
  def initialize(default_executor); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1779
class Concurrent::Promises::ImmediateFuturePromise < ::Concurrent::Promises::InnerPromise
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1780
  def initialize(default_executor, fulfilled, value, reason); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1605
class Concurrent::Promises::InnerPromise < ::Concurrent::Promises::AbstractPromise; end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#337
module Concurrent::Promises::InternalStates; end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#396
class Concurrent::Promises::InternalStates::Fulfilled < ::Concurrent::Promises::InternalStates::ResolvedWithResult
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#398
  def initialize(value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#406
  def apply(args, block); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#402
  def fulfilled?; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#414
  def reason; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#418
  def to_sym; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#410
  def value; end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#424
class Concurrent::Promises::InternalStates::FulfilledArray < ::Concurrent::Promises::InternalStates::Fulfilled
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#425
  def apply(args, block); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#487
Concurrent::Promises::InternalStates::PENDING = T.let(T.unsafe(nil), Concurrent::Promises::InternalStates::Pending)

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#458
class Concurrent::Promises::InternalStates::PartiallyRejected < ::Concurrent::Promises::InternalStates::ResolvedWithResult
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#459
  def initialize(value, reason); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#481
  def apply(args, block); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#465
  def fulfilled?; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#477
  def reason; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#469
  def to_sym; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#473
  def value; end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#350
class Concurrent::Promises::InternalStates::Pending < ::Concurrent::Promises::InternalStates::State
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#351
  def resolved?; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#355
  def to_sym; end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#489
Concurrent::Promises::InternalStates::RESERVED = T.let(T.unsafe(nil), Concurrent::Promises::InternalStates::Reserved)

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#491
Concurrent::Promises::InternalStates::RESOLVED = T.let(T.unsafe(nil), Concurrent::Promises::InternalStates::Fulfilled)

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#431
class Concurrent::Promises::InternalStates::Rejected < ::Concurrent::Promises::InternalStates::ResolvedWithResult
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#432
  def initialize(reason); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#452
  def apply(args, block); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#436
  def fulfilled?; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#444
  def reason; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#448
  def to_sym; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#440
  def value; end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#361
class Concurrent::Promises::InternalStates::Reserved < ::Concurrent::Promises::InternalStates::Pending; end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#365
class Concurrent::Promises::InternalStates::ResolvedWithResult < ::Concurrent::Promises::InternalStates::State
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#390
  def apply; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#378
  def fulfilled?; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#386
  def reason; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#366
  def resolved?; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#374
  def result; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#370
  def to_sym; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#382
  def value; end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#339
class Concurrent::Promises::InternalStates::State
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#340
  def resolved?; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#344
  def to_sym; end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1738
class Concurrent::Promises::RescuePromise < ::Concurrent::Promises::BlockedTaskPromise
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1741
  def initialize(delayed, blockers_count, default_executor, executor, args, &task); end

  private

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1745
  def on_resolvable(resolved_future, index); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1289
module Concurrent::Promises::Resolvable
  include ::Concurrent::Promises::InternalStates
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1294
class Concurrent::Promises::ResolvableEvent < ::Concurrent::Promises::Event
  include ::Concurrent::Promises::Resolvable

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1314
  def resolve(raise_on_reassign = T.unsafe(nil), reserved = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1332
  def wait(timeout = T.unsafe(nil), resolve_on_timeout = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1321
  def with_hidden_resolvable; end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1590
class Concurrent::Promises::ResolvableEventPromise < ::Concurrent::Promises::AbstractPromise
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1591
  def initialize(default_executor); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1344
class Concurrent::Promises::ResolvableFuture < ::Concurrent::Promises::Future
  include ::Concurrent::Promises::Resolvable

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1385
  def evaluate_to(*args, &block); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1396
  def evaluate_to!(*args, &block); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1365
  def fulfill(value, raise_on_reassign = T.unsafe(nil), reserved = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1493
  def reason(timeout = T.unsafe(nil), timeout_value = T.unsafe(nil), resolve_on_timeout = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1375
  def reject(reason, raise_on_reassign = T.unsafe(nil), reserved = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1355
  def resolve(fulfilled = T.unsafe(nil), value = T.unsafe(nil), reason = T.unsafe(nil), raise_on_reassign = T.unsafe(nil), reserved = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1514
  def result(timeout = T.unsafe(nil), resolve_on_timeout = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1449
  def value(timeout = T.unsafe(nil), timeout_value = T.unsafe(nil), resolve_on_timeout = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1471
  def value!(timeout = T.unsafe(nil), timeout_value = T.unsafe(nil), resolve_on_timeout = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1411
  def wait(timeout = T.unsafe(nil), resolve_on_timeout = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1428
  def wait!(timeout = T.unsafe(nil), resolve_on_timeout = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1532
  def with_hidden_resolvable; end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1596
class Concurrent::Promises::ResolvableFuturePromise < ::Concurrent::Promises::AbstractPromise
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1597
  def initialize(default_executor); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1899
class Concurrent::Promises::RunFuturePromise < ::Concurrent::Promises::AbstractFlatPromise
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1903
  def initialize(delayed, blockers_count, default_executor, run_test); end

  private

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1908
  def process_on_blocker_resolution(future, index); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#2104
class Concurrent::Promises::ScheduledPromise < ::Concurrent::Promises::InnerPromise
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#2115
  def initialize(default_executor, intended_time); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#2109
  def inspect; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#2105
  def intended_time; end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1720
class Concurrent::Promises::ThenPromise < ::Concurrent::Promises::BlockedTaskPromise
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1723
  def initialize(delayed, blockers_count, default_executor, executor, args, &task); end

  private

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1727
  def on_resolvable(resolved_future, index); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1930
class Concurrent::Promises::ZipEventEventPromise < ::Concurrent::Promises::BlockedPromise
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1931
  def initialize(delayed, blockers_count, default_executor); end

  private

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1937
  def on_resolvable(resolved_future, index); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#2021
class Concurrent::Promises::ZipEventsPromise < ::Concurrent::Promises::BlockedPromise
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#2025
  def initialize(delayed, blockers_count, default_executor); end

  private

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#2031
  def on_resolvable(resolved_future, index); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1942
class Concurrent::Promises::ZipFutureEventPromise < ::Concurrent::Promises::BlockedPromise
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1943
  def initialize(delayed, blockers_count, default_executor); end

  private

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1957
  def on_resolvable(resolved_future, index); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1950
  def process_on_blocker_resolution(future, index); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1986
class Concurrent::Promises::ZipFuturesPromise < ::Concurrent::Promises::BlockedPromise
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1990
  def initialize(delayed, blockers_count, default_executor); end

  private

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#2003
  def on_resolvable(resolved_future, index); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/promises.rb#1997
  def process_on_blocker_resolution(future, index); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/re_include.rb#36
module Concurrent::ReInclude
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/re_include.rb#44
  def extended(base); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/re_include.rb#50
  def include(*modules); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/re_include.rb#38
  def included(base); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/read_write_lock.rb#31
class Concurrent::ReadWriteLock < ::Concurrent::Synchronization::Object
  extend ::Concurrent::Synchronization::SafeInitialization

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/read_write_lock.rb#59
  def initialize; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/read_write_lock.rb#111
  def acquire_read_lock; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/read_write_lock.rb#160
  def acquire_write_lock; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/read_write_lock.rb#214
  def has_waiters?; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/read_write_lock.rb#140
  def release_read_lock; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/read_write_lock.rb#196
  def release_write_lock; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/read_write_lock.rb#75
  def with_read_lock; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/read_write_lock.rb#94
  def with_write_lock; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/read_write_lock.rb#207
  def write_locked?; end

  private

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/read_write_lock.rb#246
  def max_readers?(c = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/read_write_lock.rb#251
  def max_writers?(c = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/read_write_lock.rb#221
  def running_readers(c = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/read_write_lock.rb#226
  def running_readers?(c = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/read_write_lock.rb#231
  def running_writer?(c = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/read_write_lock.rb#241
  def waiting_writer?(c = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/read_write_lock.rb#236
  def waiting_writers(c = T.unsafe(nil)); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/read_write_lock.rb#40
Concurrent::ReadWriteLock::MAX_READERS = T.let(T.unsafe(nil), Integer)

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/read_write_lock.rb#43
Concurrent::ReadWriteLock::MAX_WRITERS = T.let(T.unsafe(nil), Integer)

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/read_write_lock.rb#37
Concurrent::ReadWriteLock::RUNNING_WRITER = T.let(T.unsafe(nil), Integer)

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/read_write_lock.rb#34
Concurrent::ReadWriteLock::WAITING_WRITER = T.let(T.unsafe(nil), Integer)

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#53
class Concurrent::ReentrantReadWriteLock < ::Concurrent::Synchronization::Object
  extend ::Concurrent::Synchronization::SafeInitialization

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#109
  def initialize; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#162
  def acquire_read_lock; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#257
  def acquire_write_lock; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#236
  def release_read_lock; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#329
  def release_write_lock; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#215
  def try_read_lock; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#310
  def try_write_lock; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#126
  def with_read_lock; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#145
  def with_write_lock; end

  private

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#370
  def max_readers?(c = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#375
  def max_writers?(c = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#345
  def running_readers(c = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#350
  def running_readers?(c = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#355
  def running_writer?(c = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#365
  def waiting_or_running_writer?(c = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#360
  def waiting_writers(c = T.unsafe(nil)); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#94
Concurrent::ReentrantReadWriteLock::MAX_READERS = T.let(T.unsafe(nil), Integer)

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#96
Concurrent::ReentrantReadWriteLock::MAX_WRITERS = T.let(T.unsafe(nil), Integer)

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#84
Concurrent::ReentrantReadWriteLock::READER_BITS = T.let(T.unsafe(nil), Integer)

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#102
Concurrent::ReentrantReadWriteLock::READ_LOCK_MASK = T.let(T.unsafe(nil), Integer)

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#92
Concurrent::ReentrantReadWriteLock::RUNNING_WRITER = T.let(T.unsafe(nil), Integer)

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#90
Concurrent::ReentrantReadWriteLock::WAITING_WRITER = T.let(T.unsafe(nil), Integer)

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#86
Concurrent::ReentrantReadWriteLock::WRITER_BITS = T.let(T.unsafe(nil), Integer)

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#100
Concurrent::ReentrantReadWriteLock::WRITE_LOCK_HELD = T.let(T.unsafe(nil), Integer)

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/reentrant_read_write_lock.rb#104
Concurrent::ReentrantReadWriteLock::WRITE_LOCK_MASK = T.let(T.unsafe(nil), Integer)

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/errors.rb#48
class Concurrent::RejectedExecutionError < ::Concurrent::Error; end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/errors.rb#52
class Concurrent::ResourceLimitError < ::Concurrent::Error; end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/exchanger.rb#134
class Concurrent::RubyExchanger < ::Concurrent::AbstractExchanger
  extend ::Concurrent::Synchronization::SafeInitialization

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/exchanger.rb#159
  def initialize; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/object.rb#137
  def __initialize_atomic_fields__; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/object.rb#105
  def compare_and_set_slot(expected, value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/object.rb#93
  def slot; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/object.rb#97
  def slot=(value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/object.rb#101
  def swap_slot(value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/object.rb#109
  def update_slot(&block); end

  private

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/exchanger.rb#170
  def do_exchange(value, timeout); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/exchanger.rb#138
class Concurrent::RubyExchanger::Node < ::Concurrent::Synchronization::Object
  extend ::Concurrent::Synchronization::SafeInitialization

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/exchanger.rb#142
  def initialize(item); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/object.rb#137
  def __initialize_atomic_fields__; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/object.rb#105
  def compare_and_set_value(expected, value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/exchanger.rb#153
  def item; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/exchanger.rb#149
  def latch; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/object.rb#101
  def swap_value(value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/object.rb#109
  def update_value(&block); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/object.rb#93
  def value; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/object.rb#97
  def value=(value); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_executor_service.rb#8
class Concurrent::RubyExecutorService < ::Concurrent::AbstractExecutorService
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_executor_service.rb#11
  def initialize(*args, &block); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_executor_service.rb#42
  def kill; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_executor_service.rb#17
  def post(*args, &task); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_executor_service.rb#33
  def shutdown; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_executor_service.rb#52
  def wait_for_termination(timeout = T.unsafe(nil)); end

  private

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_executor_service.rb#70
  def ns_running?; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_executor_service.rb#78
  def ns_shutdown?; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_executor_service.rb#66
  def ns_shutdown_execution; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_executor_service.rb#74
  def ns_shuttingdown?; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_executor_service.rb#58
  def stop_event; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_executor_service.rb#62
  def stopped_event; end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_single_thread_executor.rb#8
class Concurrent::RubySingleThreadExecutor < ::Concurrent::RubyThreadPoolExecutor
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_single_thread_executor.rb#11
  def initialize(opts = T.unsafe(nil)); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#12
class Concurrent::RubyThreadPoolExecutor < ::Concurrent::RubyExecutorService
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#45
  def initialize(opts = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#65
  def can_overflow?; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#60
  def completed_task_count; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#36
  def idletime; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#50
  def largest_length; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#70
  def length; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#30
  def max_length; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#39
  def max_queue; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#33
  def min_length; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#111
  def prune_pool; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#75
  def queue_length; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#96
  def ready_worker(worker, last_message); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#80
  def remaining_capacity; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#91
  def remove_busy_worker(worker); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#55
  def scheduled_task_count; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#42
  def synchronous; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#101
  def worker_died(worker); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#106
  def worker_task_completed; end

  private

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#234
  def ns_add_busy_worker; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#194
  def ns_assign_worker(*args, &task); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#212
  def ns_enqueue(*args, &task); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#153
  def ns_execute(*args, &task); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#118
  def ns_initialize(opts); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#182
  def ns_kill_execution; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#148
  def ns_limited_queue?; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#273
  def ns_prune_pool; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#246
  def ns_ready_worker(worker, last_message, success = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#264
  def ns_remove_busy_worker(worker); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#289
  def ns_reset_if_forked; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#167
  def ns_shutdown_execution; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#224
  def ns_worker_died(worker); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#15
Concurrent::RubyThreadPoolExecutor::DEFAULT_MAX_POOL_SIZE = T.let(T.unsafe(nil), Integer)

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#21
Concurrent::RubyThreadPoolExecutor::DEFAULT_MAX_QUEUE_SIZE = T.let(T.unsafe(nil), Integer)

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#18
Concurrent::RubyThreadPoolExecutor::DEFAULT_MIN_POOL_SIZE = T.let(T.unsafe(nil), Integer)

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#27
Concurrent::RubyThreadPoolExecutor::DEFAULT_SYNCHRONOUS = T.let(T.unsafe(nil), FalseClass)

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#24
Concurrent::RubyThreadPoolExecutor::DEFAULT_THREAD_IDLETIMEOUT = T.let(T.unsafe(nil), Integer)

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#303
class Concurrent::RubyThreadPoolExecutor::Worker
  include ::Logger::Severity
  include ::Concurrent::Concern::Logging

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#306
  def initialize(pool, id); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#317
  def <<(message); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#325
  def kill; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#321
  def stop; end

  private

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#331
  def create_worker(queue, pool, idletime); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/ruby_thread_pool_executor.rb#351
  def run_task(pool, task, args); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/safe_task_executor.rb#9
class Concurrent::SafeTaskExecutor < ::Concurrent::Synchronization::LockableObject
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/safe_task_executor.rb#11
  def initialize(task, opts = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/safe_task_executor.rb#18
  def execute(*args); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/scheduled_task.rb#158
class Concurrent::ScheduledTask < ::Concurrent::IVar
  include ::Comparable

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/scheduled_task.rb#178
  def initialize(delay, opts = T.unsafe(nil), &task); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/scheduled_task.rb#213
  def <=>(other); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/scheduled_task.rb#235
  def cancel; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/scheduled_task.rb#220
  def cancelled?; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/scheduled_task.rb#273
  def execute; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/scheduled_task.rb#163
  def executor; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/scheduled_task.rb#199
  def initial_delay; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/scheduled_task.rb#297
  def process_task; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/scheduled_task.rb#227
  def processing?; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/scheduled_task.rb#262
  def reschedule(delay); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/scheduled_task.rb#250
  def reset; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/scheduled_task.rb#206
  def schedule_time; end

  protected

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/scheduled_task.rb#326
  def ns_reschedule(delay); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/scheduled_task.rb#312
  def ns_schedule(delay); end

  class << self
    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/scheduled_task.rb#290
    def execute(delay, opts = T.unsafe(nil), &task); end
  end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/semaphore.rb#161
class Concurrent::Semaphore < ::Concurrent::MutexSemaphore; end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/semaphore.rb#96
Concurrent::SemaphoreImplementation = Concurrent::MutexSemaphore

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/serial_executor_service.rb#24
module Concurrent::SerialExecutorService
  include ::Logger::Severity
  include ::Concurrent::Concern::Logging
  include ::Concurrent::ExecutorService

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/serial_executor_service.rb#30
  def serialized?; end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/serialized_execution.rb#8
class Concurrent::SerializedExecution < ::Concurrent::Synchronization::LockableObject
  include ::Logger::Severity
  include ::Concurrent::Concern::Logging

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/serialized_execution.rb#11
  def initialize; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/serialized_execution.rb#34
  def post(executor, *args, &task); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/serialized_execution.rb#44
  def posts(posts); end

  private

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/serialized_execution.rb#75
  def call_job(job); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/serialized_execution.rb#70
  def ns_initialize; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/serialized_execution.rb#95
  def work(job); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/serialized_execution.rb#16
class Concurrent::SerializedExecution::Job < ::Struct
  def args; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/serialized_execution.rb#16
  def args=(_); end

  def block; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/serialized_execution.rb#16
  def block=(_); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/serialized_execution.rb#17
  def call; end

  def executor; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/serialized_execution.rb#16
  def executor=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/serialized_execution_delegator.rb#12
class Concurrent::SerializedExecutionDelegator < ::SimpleDelegator
  include ::Logger::Severity
  include ::Concurrent::Concern::Logging
  include ::Concurrent::ExecutorService
  include ::Concurrent::SerialExecutorService

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/serialized_execution_delegator.rb#15
  def initialize(executor); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/serialized_execution_delegator.rb#22
  def post(*args, &task); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/set.rb#61
class Concurrent::Set < ::Concurrent::CRubySet; end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/set.rb#23
Concurrent::SetImplementation = Concurrent::CRubySet

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/settable_struct.rb#14
module Concurrent::SettableStruct
  include ::Concurrent::Synchronization::AbstractStruct

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/settable_struct.rb#50
  def ==(other); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/settable_struct.rb#45
  def [](member); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/settable_struct.rb#75
  def []=(member, value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/settable_struct.rb#55
  def each(&block); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/settable_struct.rb#61
  def each_pair(&block); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/settable_struct.rb#29
  def inspect; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/settable_struct.rb#35
  def merge(other, &block); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/settable_struct.rb#67
  def select(&block); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/settable_struct.rb#18
  def to_a; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/settable_struct.rb#40
  def to_h; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/settable_struct.rb#29
  def to_s; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/settable_struct.rb#18
  def values; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/settable_struct.rb#24
  def values_at(*indexes); end

  private

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/settable_struct.rb#97
  def initialize_copy(original); end

  class << self
    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/settable_struct.rb#105
    def new(*args, &block); end
  end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/settable_struct.rb#115
Concurrent::SettableStruct::FACTORY = T.let(T.unsafe(nil), T.untyped)

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/simple_executor_service.rb#21
class Concurrent::SimpleExecutorService < ::Concurrent::RubyExecutorService
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/simple_executor_service.rb#56
  def <<(task); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/simple_executor_service.rb#84
  def kill; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/simple_executor_service.rb#40
  def post(*args, &task); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/simple_executor_service.rb#62
  def running?; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/simple_executor_service.rb#77
  def shutdown; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/simple_executor_service.rb#72
  def shutdown?; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/simple_executor_service.rb#67
  def shuttingdown?; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/simple_executor_service.rb#91
  def wait_for_termination(timeout = T.unsafe(nil)); end

  private

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/simple_executor_service.rb#97
  def ns_initialize(*args); end

  class << self
    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/simple_executor_service.rb#34
    def <<(task); end

    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/simple_executor_service.rb#24
    def post(*args); end
  end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/single_thread_executor.rb#37
class Concurrent::SingleThreadExecutor < ::Concurrent::RubySingleThreadExecutor; end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/single_thread_executor.rb#10
Concurrent::SingleThreadExecutorImplementation = Concurrent::RubySingleThreadExecutor

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/abstract_object.rb#2
module Concurrent::Synchronization
  class << self
    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/full_memory_barrier.rb#7
    def full_memory_barrier; end
  end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/abstract_lockable_object.rb#9
class Concurrent::Synchronization::AbstractLockableObject < ::Concurrent::Synchronization::Object
  protected

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/abstract_lockable_object.rb#96
  def ns_broadcast; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/abstract_lockable_object.rb#81
  def ns_signal; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/abstract_lockable_object.rb#66
  def ns_wait(timeout = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/abstract_lockable_object.rb#37
  def ns_wait_until(timeout = T.unsafe(nil), &condition); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/abstract_lockable_object.rb#18
  def synchronize; end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/abstract_object.rb#6
class Concurrent::Synchronization::AbstractObject
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/abstract_object.rb#7
  def initialize; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/abstract_object.rb#13
  def full_memory_barrier; end

  class << self
    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/abstract_object.rb#17
    def attr_volatile(*names); end
  end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/abstract_struct.rb#6
module Concurrent::Synchronization::AbstractStruct
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/abstract_struct.rb#9
  def initialize(*values); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/abstract_struct.rb#19
  def length; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/abstract_struct.rb#29
  def members; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/abstract_struct.rb#19
  def size; end

  protected

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/abstract_struct.rb#82
  def ns_each; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/abstract_struct.rb#89
  def ns_each_pair; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/abstract_struct.rb#75
  def ns_equality(other); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/abstract_struct.rb#59
  def ns_get(member); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/abstract_struct.rb#119
  def ns_initialize_copy; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/abstract_struct.rb#105
  def ns_inspect; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/abstract_struct.rb#114
  def ns_merge(other, &block); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/abstract_struct.rb#98
  def ns_select; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/abstract_struct.rb#52
  def ns_to_h; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/abstract_struct.rb#38
  def ns_values; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/abstract_struct.rb#45
  def ns_values_at(indexes); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/abstract_struct.rb#130
  def pr_underscore(clazz); end

  class << self
    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/abstract_struct.rb#141
    def define_struct_class(parent, base, name, members, &block); end
  end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/condition.rb#8
class Concurrent::Synchronization::Condition < ::Concurrent::Synchronization::LockableObject
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/condition.rb#18
  def initialize(lock); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/condition.rb#47
  def broadcast; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/condition.rb#51
  def ns_broadcast; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/condition.rb#43
  def ns_signal; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/condition.rb#27
  def ns_wait(timeout = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/condition.rb#35
  def ns_wait_until(timeout = T.unsafe(nil), &condition); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/condition.rb#39
  def signal; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/condition.rb#23
  def wait(timeout = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/condition.rb#31
  def wait_until(timeout = T.unsafe(nil), &condition); end

  class << self
    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/safe_initialization.rb#29
    def private_new(*args, &block); end
  end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/mutex_lockable_object.rb#8
module Concurrent::Synchronization::ConditionSignalling
  protected

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/mutex_lockable_object.rb#16
  def ns_broadcast; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/mutex_lockable_object.rb#11
  def ns_signal; end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/lock.rb#9
class Concurrent::Synchronization::Lock < ::Concurrent::Synchronization::LockableObject
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/lock.rb#31
  def broadcast; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/lock.rb#25
  def signal; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/lock.rb#13
  def wait(timeout = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/lock.rb#19
  def wait_until(timeout = T.unsafe(nil), &condition); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/lockable_object.rb#50
class Concurrent::Synchronization::LockableObject < ::Concurrent::Synchronization::MutexLockableObject
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/condition.rb#57
  def new_condition; end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/lockable_object.rb#11
Concurrent::Synchronization::LockableObjectImplementation = Concurrent::Synchronization::MutexLockableObject

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/mutex_lockable_object.rb#60
class Concurrent::Synchronization::MonitorLockableObject < ::Concurrent::Synchronization::AbstractLockableObject
  include ::Concurrent::Synchronization::ConditionSignalling
  extend ::Concurrent::Synchronization::SafeInitialization

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/mutex_lockable_object.rb#65
  def initialize; end

  protected

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/mutex_lockable_object.rb#83
  def ns_wait(timeout = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/mutex_lockable_object.rb#79
  def synchronize; end

  private

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/mutex_lockable_object.rb#71
  def initialize_copy(other); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/mutex_lockable_object.rb#25
class Concurrent::Synchronization::MutexLockableObject < ::Concurrent::Synchronization::AbstractLockableObject
  include ::Concurrent::Synchronization::ConditionSignalling
  extend ::Concurrent::Synchronization::SafeInitialization

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/mutex_lockable_object.rb#30
  def initialize; end

  protected

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/mutex_lockable_object.rb#52
  def ns_wait(timeout = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/mutex_lockable_object.rb#44
  def synchronize; end

  private

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/mutex_lockable_object.rb#36
  def initialize_copy(other); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/object.rb#15
class Concurrent::Synchronization::Object < ::Concurrent::Synchronization::AbstractObject
  include ::Concurrent::Synchronization::Volatile
  extend ::Concurrent::Synchronization::Volatile::ClassMethods

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/object.rb#28
  def initialize; end

  private

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/object.rb#146
  def __initialize_atomic_fields__; end

  class << self
    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/object.rb#125
    def atomic_attribute?(name); end

    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/object.rb#119
    def atomic_attributes(inherited = T.unsafe(nil)); end

    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/object.rb#84
    def attr_atomic(*names); end

    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/object.rb#45
    def ensure_safe_initialization_when_final_fields_are_present; end

    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/object.rb#33
    def safe_initialization!; end

    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/object.rb#37
    def safe_initialization?; end

    private

    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/object.rb#131
    def define_initialize_atomic_fields; end
  end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/safe_initialization.rb#28
module Concurrent::Synchronization::SafeInitialization
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/safe_initialization.rb#29
  def new(*args, &block); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/volatile.rb#28
module Concurrent::Synchronization::Volatile
  mixes_in_class_methods ::Concurrent::Synchronization::Volatile::ClassMethods

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/volatile.rb#33
  def full_memory_barrier; end

  class << self
    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/volatile.rb#29
    def included(base); end
  end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/volatile.rb#37
module Concurrent::Synchronization::Volatile::ClassMethods
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/synchronization/volatile.rb#39
  def attr_volatile(*names); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/synchronized_delegator.rb#21
class Concurrent::SynchronizedDelegator < ::SimpleDelegator
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/synchronized_delegator.rb#31
  def initialize(obj); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/synchronized_delegator.rb#36
  def method_missing(method, *args, &block); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/synchronized_delegator.rb#22
  def setup; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/synchronized_delegator.rb#27
  def teardown; end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/tvar.rb#12
class Concurrent::TVar < ::Concurrent::Synchronization::Object
  extend ::Concurrent::Synchronization::SafeInitialization

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/tvar.rb#16
  def initialize(value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/tvar.rb#46
  def unsafe_lock; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/tvar.rb#36
  def unsafe_value; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/tvar.rb#41
  def unsafe_value=(value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/tvar.rb#22
  def value; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/tvar.rb#29
  def value=(value); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/thread_local_var.rb#43
class Concurrent::ThreadLocalVar
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/thread_local_var.rb#51
  def initialize(default = T.unsafe(nil), &default_block); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/thread_local_var.rb#88
  def bind(value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/thread_local_var.rb#70
  def value; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/thread_local_var.rb#78
  def value=(value); end

  protected

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/thread_local_var.rb#103
  def default; end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/thread_local_var.rb#44
Concurrent::ThreadLocalVar::LOCALS = T.let(T.unsafe(nil), Concurrent::ThreadLocals)

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/locals.rb#141
class Concurrent::ThreadLocals < ::Concurrent::AbstractLocals
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/locals.rb#142
  def locals; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/atomic/locals.rb#146
  def locals!; end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/thread_pool_executor.rb#56
class Concurrent::ThreadPoolExecutor < ::Concurrent::RubyThreadPoolExecutor; end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/thread_pool_executor.rb#10
Concurrent::ThreadPoolExecutorImplementation = Concurrent::RubyThreadPoolExecutor

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/util.rb#4
module Concurrent::ThreadSafe; end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/util.rb#7
module Concurrent::ThreadSafe::Util
  class << self
    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/util/data_structures.rb#16
    def make_synchronized_on_cruby(klass); end

    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/util/data_structures.rb#41
    def make_synchronized_on_truffleruby(klass); end
  end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/util.rb#13
Concurrent::ThreadSafe::Util::CPU_COUNT = T.let(T.unsafe(nil), Integer)

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/util.rb#10
Concurrent::ThreadSafe::Util::FIXNUM_BIT_SIZE = T.let(T.unsafe(nil), Integer)

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/thread_safe/util.rb#11
Concurrent::ThreadSafe::Util::MAX_INT = T.let(T.unsafe(nil), Integer)

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/errors.rb#55
class Concurrent::TimeoutError < ::Concurrent::Error; end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/timer_set.rb#19
class Concurrent::TimerSet < ::Concurrent::RubyExecutorService
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/timer_set.rb#30
  def initialize(opts = T.unsafe(nil)); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/timer_set.rb#62
  def kill; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/timer_set.rb#48
  def post(delay, *args, &task); end

  private

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/timer_set.rb#74
  def ns_initialize(opts); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/timer_set.rb#94
  def ns_post_task(task); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/timer_set.rb#129
  def ns_reset_if_forked; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/timer_set.rb#122
  def ns_shutdown_execution; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/timer_set.rb#89
  def post_task(task); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/timer_set.rb#143
  def process_tasks; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/executor/timer_set.rb#115
  def remove_task(task); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/timer_task.rb#148
class Concurrent::TimerTask < ::Concurrent::RubyExecutorService
  include ::Concurrent::Concern::Dereferenceable
  include ::Concurrent::Concern::Observable

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/timer_task.rb#180
  def initialize(opts = T.unsafe(nil), &task); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/timer_task.rb#206
  def execute; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/timer_task.rb#230
  def execution_interval; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/timer_task.rb#237
  def execution_interval=(value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/timer_task.rb#189
  def running?; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/timer_task.rb#248
  def timeout_interval; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/timer_task.rb#255
  def timeout_interval=(value); end

  private

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/timer_task.rb#297
  def execute_task(completion); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/timer_task.rb#263
  def ns_initialize(opts, &task); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/timer_task.rb#285
  def ns_kill_execution; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/timer_task.rb#279
  def ns_shutdown_execution; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/timer_task.rb#291
  def schedule_next_task(interval = T.unsafe(nil)); end

  class << self
    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/timer_task.rb#223
    def execute(opts = T.unsafe(nil), &task); end
  end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/timer_task.rb#153
Concurrent::TimerTask::EXECUTION_INTERVAL = T.let(T.unsafe(nil), Integer)

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/timer_task.rb#156
Concurrent::TimerTask::TIMEOUT_INTERVAL = T.let(T.unsafe(nil), Integer)

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/tvar.rb#153
class Concurrent::Transaction
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/tvar.rb#162
  def initialize; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/tvar.rb#192
  def abort; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/tvar.rb#196
  def commit; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/tvar.rb#177
  def open(tvar); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/tvar.rb#166
  def read(tvar); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/tvar.rb#206
  def unlock; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/tvar.rb#171
  def write(tvar, value); end

  class << self
    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/tvar.rb#212
    def current; end

    # source://concurrent-ruby//lib/concurrent-ruby/concurrent/tvar.rb#216
    def current=(transaction); end
  end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/tvar.rb#155
Concurrent::Transaction::ABORTED = T.let(T.unsafe(nil), Object)

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/tvar.rb#159
class Concurrent::Transaction::AbortError < ::StandardError; end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/tvar.rb#160
class Concurrent::Transaction::LeaveError < ::StandardError; end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/tvar.rb#157
class Concurrent::Transaction::OpenEntry < ::Struct
  def modified; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/tvar.rb#157
  def modified=(_); end

  def value; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/tvar.rb#157
  def value=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/tuple.rb#20
class Concurrent::Tuple
  include ::Enumerable

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/tuple.rb#29
  def initialize(size); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/tuple.rb#69
  def cas(i, old_value, new_value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/tuple.rb#69
  def compare_and_set(i, old_value, new_value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/tuple.rb#78
  def each; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/tuple.rb#43
  def get(i); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/tuple.rb#55
  def set(i, value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/tuple.rb#24
  def size; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/tuple.rb#43
  def volatile_get(i); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/tuple.rb#55
  def volatile_set(i, value); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/engine.rb#3
module Concurrent::Utility; end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/engine.rb#6
module Concurrent::Utility::EngineDetector
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/engine.rb#7
  def on_cruby?; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/engine.rb#11
  def on_jruby?; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/engine.rb#27
  def on_linux?; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/engine.rb#23
  def on_osx?; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/engine.rb#15
  def on_truffleruby?; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/engine.rb#19
  def on_windows?; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/engine.rb#31
  def ruby_version(version = T.unsafe(nil), comparison, major, minor, patch); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/native_extension_loader.rb#9
module Concurrent::Utility::NativeExtensionLoader
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/native_extension_loader.rb#11
  def allow_c_extensions?; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/native_extension_loader.rb#15
  def c_extensions_loaded?; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/native_extension_loader.rb#19
  def load_native_extensions; end

  private

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/native_extension_loader.rb#50
  def java_extensions_loaded?; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/native_extension_loader.rb#38
  def load_error_path(error); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/native_extension_loader.rb#46
  def set_c_extensions_loaded; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/native_extension_loader.rb#54
  def set_java_extensions_loaded; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/native_extension_loader.rb#58
  def try_load_c_extension(path); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/native_integer.rb#5
module Concurrent::Utility::NativeInteger
  extend ::Concurrent::Utility::NativeInteger

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/native_integer.rb#24
  def ensure_integer(value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/native_integer.rb#31
  def ensure_integer_and_bounds(value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/native_integer.rb#17
  def ensure_lower_bound(value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/native_integer.rb#37
  def ensure_positive(value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/native_integer.rb#44
  def ensure_positive_and_no_zero(value); end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/native_integer.rb#10
  def ensure_upper_bound(value); end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/native_integer.rb#8
Concurrent::Utility::NativeInteger::MAX_VALUE = T.let(T.unsafe(nil), Integer)

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/native_integer.rb#7
Concurrent::Utility::NativeInteger::MIN_VALUE = T.let(T.unsafe(nil), Integer)

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/processor_counter.rb#10
class Concurrent::Utility::ProcessorCounter
  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/processor_counter.rb#11
  def initialize; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/processor_counter.rb#20
  def physical_processor_count; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/processor_counter.rb#16
  def processor_count; end

  private

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/processor_counter.rb#34
  def compute_physical_processor_count; end

  # source://concurrent-ruby//lib/concurrent-ruby/concurrent/utility/processor_counter.rb#26
  def compute_processor_count; end
end

# source://concurrent-ruby//lib/concurrent-ruby/concurrent/version.rb#2
Concurrent::VERSION = T.let(T.unsafe(nil), String)
