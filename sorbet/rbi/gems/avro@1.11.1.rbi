# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `avro` gem.
# Please instead update this file by running `bin/tapioca gem avro`.

# source://avro//lib/avro.rb#25
module Avro
  class << self
    # source://avro//lib/avro.rb#42
    def disable_enum_symbol_validation; end

    # source://avro//lib/avro.rb#38
    def disable_enum_symbol_validation=(_arg0); end

    # source://avro//lib/avro.rb#47
    def disable_field_default_validation; end

    # source://avro//lib/avro.rb#39
    def disable_field_default_validation=(_arg0); end

    # source://avro//lib/avro.rb#52
    def disable_schema_name_validation; end

    # source://avro//lib/avro.rb#40
    def disable_schema_name_validation=(_arg0); end
  end
end

# source://avro//lib/avro.rb#28
class Avro::AvroError < ::StandardError; end

# source://avro//lib/avro.rb#30
class Avro::AvroTypeError < ::Avro::AvroError
  # source://avro//lib/avro.rb#31
  def initialize(schm = T.unsafe(nil), datum = T.unsafe(nil), msg = T.unsafe(nil)); end
end

# source://avro//lib/avro/data_file.rb#21
module Avro::DataFile
  class << self
    # source://avro//lib/avro/data_file.rb#53
    def codecs; end

    # source://avro//lib/avro/data_file.rb#63
    def get_codec(codec); end

    # source://avro//lib/avro/data_file.rb#33
    def open(file_path, mode = T.unsafe(nil), schema = T.unsafe(nil), codec = T.unsafe(nil)); end

    # source://avro//lib/avro/data_file.rb#57
    def register_codec(codec); end

    private

    # source://avro//lib/avro/data_file.rb#83
    def open_reader(file, schema); end

    # source://avro//lib/avro/data_file.rb#78
    def open_writer(file, schema, codec = T.unsafe(nil)); end
  end
end

# source://avro//lib/avro/data_file.rb#31
class Avro::DataFile::DataFileError < ::Avro::AvroError; end

# source://avro//lib/avro/data_file.rb#308
class Avro::DataFile::DeflateCodec
  # source://avro//lib/avro/data_file.rb#311
  def initialize(level = T.unsafe(nil)); end

  # source://avro//lib/avro/data_file.rb#315
  def codec_name; end

  # source://avro//lib/avro/data_file.rb#328
  def compress(data); end

  # source://avro//lib/avro/data_file.rb#317
  def decompress(compressed); end

  # source://avro//lib/avro/data_file.rb#309
  def level; end
end

# source://avro//lib/avro/data_file.rb#23
Avro::DataFile::MAGIC = T.let(T.unsafe(nil), String)

# source://avro//lib/avro/data_file.rb#25
Avro::DataFile::MAGIC_SIZE = T.let(T.unsafe(nil), Integer)

# source://avro//lib/avro/data_file.rb#28
Avro::DataFile::META_SCHEMA = T.let(T.unsafe(nil), Avro::Schema::MapSchema)

# source://avro//lib/avro/data_file.rb#302
class Avro::DataFile::NullCodec
  # source://avro//lib/avro/data_file.rb#303
  def codec_name; end

  # source://avro//lib/avro/data_file.rb#305
  def compress(data); end

  # source://avro//lib/avro/data_file.rb#304
  def decompress(data); end
end

# source://avro//lib/avro/data_file.rb#203
class Avro::DataFile::Reader
  include ::Enumerable

  # source://avro//lib/avro/data_file.rb#215
  def initialize(reader, datum_reader); end

  # source://avro//lib/avro/data_file.rb#213
  def block_count; end

  # source://avro//lib/avro/data_file.rb#213
  def block_count=(_arg0); end

  # source://avro//lib/avro/data_file.rb#210
  def block_decoder; end

  # source://avro//lib/avro/data_file.rb#253
  def close; end

  # source://avro//lib/avro/data_file.rb#212
  def codec; end

  # source://avro//lib/avro/data_file.rb#212
  def datum_reader; end

  # source://avro//lib/avro/data_file.rb#207
  def decoder; end

  # source://avro//lib/avro/data_file.rb#232
  def each; end

  # source://avro//lib/avro/data_file.rb#251
  def eof?; end

  # source://avro//lib/avro/data_file.rb#212
  def file_length; end

  # source://avro//lib/avro/data_file.rb#212
  def meta; end

  # source://avro//lib/avro/data_file.rb#207
  def reader; end

  # source://avro//lib/avro/data_file.rb#212
  def sync_marker; end

  private

  # source://avro//lib/avro/data_file.rb#280
  def read_block_header; end

  # source://avro//lib/avro/data_file.rb#258
  def read_header; end

  # source://avro//lib/avro/data_file.rb#290
  def skip_sync; end
end

# source://avro//lib/avro/data_file.rb#27
Avro::DataFile::SYNC_INTERVAL = T.let(T.unsafe(nil), Integer)

# source://avro//lib/avro/data_file.rb#26
Avro::DataFile::SYNC_SIZE = T.let(T.unsafe(nil), Integer)

# source://avro//lib/avro/data_file.rb#337
class Avro::DataFile::SnappyCodec
  # source://avro//lib/avro/data_file.rb#338
  def codec_name; end

  # source://avro//lib/avro/data_file.rb#360
  def compress(data); end

  # source://avro//lib/avro/data_file.rb#340
  def decompress(data); end

  private

  # source://avro//lib/avro/data_file.rb#369
  def load_snappy!; end
end

# source://avro//lib/avro/data_file.rb#405
Avro::DataFile::VALID_CODECS = T.let(T.unsafe(nil), Array)

# source://avro//lib/avro/data_file.rb#29
Avro::DataFile::VALID_ENCODINGS = T.let(T.unsafe(nil), Array)

# source://avro//lib/avro/data_file.rb#22
Avro::DataFile::VERSION = T.let(T.unsafe(nil), Integer)

# source://avro//lib/avro/data_file.rb#89
class Avro::DataFile::Writer
  # source://avro//lib/avro/data_file.rb#97
  def initialize(writer, datum_writer, writers_schema = T.unsafe(nil), codec = T.unsafe(nil), meta = T.unsafe(nil)); end

  # source://avro//lib/avro/data_file.rb#136
  def <<(datum); end

  # source://avro//lib/avro/data_file.rb#95
  def block_count; end

  # source://avro//lib/avro/data_file.rb#95
  def block_count=(_arg0); end

  # source://avro//lib/avro/data_file.rb#94
  def buffer_encoder; end

  # source://avro//lib/avro/data_file.rb#94
  def buffer_writer; end

  # source://avro//lib/avro/data_file.rb#161
  def close; end

  # source://avro//lib/avro/data_file.rb#94
  def codec; end

  # source://avro//lib/avro/data_file.rb#94
  def datum_writer; end

  # source://avro//lib/avro/data_file.rb#94
  def encoder; end

  # source://avro//lib/avro/data_file.rb#156
  def flush; end

  # source://avro//lib/avro/data_file.rb#94
  def meta; end

  # source://avro//lib/avro/data_file.rb#150
  def sync; end

  # source://avro//lib/avro/data_file.rb#94
  def sync_marker; end

  # source://avro//lib/avro/data_file.rb#94
  def writer; end

  private

  # source://avro//lib/avro/data_file.rb#181
  def write_block; end

  # source://avro//lib/avro/data_file.rb#168
  def write_header; end

  class << self
    # source://avro//lib/avro/data_file.rb#90
    def generate_sync_marker; end
  end
end

# source://avro//lib/avro/data_file.rb#376
class Avro::DataFile::ZstandardCodec
  # source://avro//lib/avro/data_file.rb#377
  def codec_name; end

  # source://avro//lib/avro/data_file.rb#384
  def compress(data); end

  # source://avro//lib/avro/data_file.rb#379
  def decompress(data); end

  private

  # source://avro//lib/avro/data_file.rb#391
  def load_zstandard!; end
end

# source://avro//lib/avro/io.rb#19
module Avro::IO; end

# source://avro//lib/avro/io.rb#21
class Avro::IO::AvroTypeError < ::Avro::AvroError
  # source://avro//lib/avro/io.rb#22
  def initialize(expected_schema, datum); end
end

# source://avro//lib/avro/io.rb#37
class Avro::IO::BinaryDecoder
  # source://avro//lib/avro/io.rb#42
  def initialize(reader); end

  # source://avro//lib/avro/io.rb#46
  def byte!; end

  # source://avro//lib/avro/io.rb#105
  def read(len); end

  # source://avro//lib/avro/io.rb#55
  def read_boolean; end

  # source://avro//lib/avro/io.rb#91
  def read_bytes; end

  # source://avro//lib/avro/io.rb#83
  def read_double; end

  # source://avro//lib/avro/io.rb#75
  def read_float; end

  # source://avro//lib/avro/io.rb#59
  def read_int; end

  # source://avro//lib/avro/io.rb#61
  def read_long; end

  # source://avro//lib/avro/io.rb#50
  def read_null; end

  # source://avro//lib/avro/io.rb#97
  def read_string; end

  # source://avro//lib/avro/io.rb#41
  def reader; end

  # source://avro//lib/avro/io.rb#145
  def skip(n); end

  # source://avro//lib/avro/io.rb#114
  def skip_boolean; end

  # source://avro//lib/avro/io.rb#137
  def skip_bytes; end

  # source://avro//lib/avro/io.rb#133
  def skip_double; end

  # source://avro//lib/avro/io.rb#129
  def skip_float; end

  # source://avro//lib/avro/io.rb#118
  def skip_int; end

  # source://avro//lib/avro/io.rb#122
  def skip_long; end

  # source://avro//lib/avro/io.rb#110
  def skip_null; end

  # source://avro//lib/avro/io.rb#141
  def skip_string; end

  private

  # source://avro//lib/avro/io.rb#154
  def read_and_unpack(byte_count, format); end
end

# source://avro//lib/avro/io.rb#168
class Avro::IO::BinaryEncoder
  # source://avro//lib/avro/io.rb#171
  def initialize(writer); end

  # source://avro//lib/avro/io.rb#234
  def write(datum); end

  # source://avro//lib/avro/io.rb#182
  def write_boolean(datum); end

  # source://avro//lib/avro/io.rb#221
  def write_bytes(datum); end

  # source://avro//lib/avro/io.rb#216
  def write_double(datum); end

  # source://avro//lib/avro/io.rb#208
  def write_float(datum); end

  # source://avro//lib/avro/io.rb#189
  def write_int(n); end

  # source://avro//lib/avro/io.rb#195
  def write_long(n); end

  # source://avro//lib/avro/io.rb#176
  def write_null(_datum); end

  # source://avro//lib/avro/io.rb#228
  def write_string(datum); end

  # source://avro//lib/avro/io.rb#169
  def writer; end
end

# source://avro//lib/avro/io.rb#239
class Avro::IO::DatumReader
  # source://avro//lib/avro/io.rb#246
  def initialize(writers_schema = T.unsafe(nil), readers_schema = T.unsafe(nil)); end

  # source://avro//lib/avro/io.rb#251
  def read(decoder); end

  # source://avro//lib/avro/io.rb#313
  def read_array(writers_schema, readers_schema, decoder); end

  # source://avro//lib/avro/io.rb#256
  def read_data(writers_schema, readers_schema, decoder); end

  # source://avro//lib/avro/io.rb#391
  def read_default_value(field_schema, default_value); end

  # source://avro//lib/avro/io.rb#300
  def read_enum(writers_schema, readers_schema, decoder); end

  # source://avro//lib/avro/io.rb#296
  def read_fixed(writers_schema, _readers_schema, decoder); end

  # source://avro//lib/avro/io.rb#332
  def read_map(writers_schema, readers_schema, decoder); end

  # source://avro//lib/avro/io.rb#359
  def read_record(writers_schema, readers_schema, decoder); end

  # source://avro//lib/avro/io.rb#352
  def read_union(writers_schema, readers_schema, decoder); end

  # source://avro//lib/avro/io.rb#244
  def readers_schema; end

  # source://avro//lib/avro/io.rb#244
  def readers_schema=(_arg0); end

  # source://avro//lib/avro/io.rb#481
  def skip_array(writers_schema, decoder); end

  # source://avro//lib/avro/io.rb#433
  def skip_data(writers_schema, decoder); end

  # source://avro//lib/avro/io.rb#472
  def skip_enum(_writers_schema, decoder); end

  # source://avro//lib/avro/io.rb#468
  def skip_fixed(writers_schema, decoder); end

  # source://avro//lib/avro/io.rb#485
  def skip_map(writers_schema, decoder); end

  # source://avro//lib/avro/io.rb#492
  def skip_record(writers_schema, decoder); end

  # source://avro//lib/avro/io.rb#476
  def skip_union(writers_schema, decoder); end

  # source://avro//lib/avro/io.rb#244
  def writers_schema; end

  # source://avro//lib/avro/io.rb#244
  def writers_schema=(_arg0); end

  private

  # source://avro//lib/avro/io.rb#497
  def skip_blocks(decoder, &blk); end

  class << self
    # source://avro//lib/avro/io.rb#240
    def match_schemas(writers_schema, readers_schema); end
  end
end

# source://avro//lib/avro/io.rb#511
class Avro::IO::DatumWriter
  # source://avro//lib/avro/io.rb#515
  def initialize(writers_schema = T.unsafe(nil)); end

  # source://avro//lib/avro/io.rb#519
  def write(datum, encoder); end

  # source://avro//lib/avro/io.rb#560
  def write_array(writers_schema, datum, encoder); end

  # source://avro//lib/avro/io.rb#523
  def write_data(writers_schema, logical_datum, encoder); end

  # source://avro//lib/avro/io.rb#555
  def write_enum(writers_schema, datum, encoder); end

  # source://avro//lib/avro/io.rb#551
  def write_fixed(_writers_schema, datum, encoder); end

  # source://avro//lib/avro/io.rb#571
  def write_map(writers_schema, datum, encoder); end

  # source://avro//lib/avro/io.rb#597
  def write_record(writers_schema, datum, encoder); end

  # source://avro//lib/avro/io.rb#583
  def write_union(writers_schema, datum, encoder); end

  # source://avro//lib/avro/io.rb#514
  def writers_schema; end

  # source://avro//lib/avro/io.rb#514
  def writers_schema=(_arg0); end
end

# source://avro//lib/avro/io.rb#512
Avro::IO::DatumWriter::VALIDATION_OPTIONS = T.let(T.unsafe(nil), Hash)

# source://avro//lib/avro/io.rb#28
class Avro::IO::SchemaMatchException < ::Avro::AvroError
  # source://avro//lib/avro/io.rb#29
  def initialize(writers_schema, readers_schema); end
end

# source://avro//lib/avro/ipc.rb#20
module Avro::IPC; end

# source://avro//lib/avro/ipc.rb#22
class Avro::IPC::AvroRemoteError < ::Avro::AvroError; end

# source://avro//lib/avro/ipc.rb#77
class Avro::IPC::AvroRemoteException < ::Avro::AvroError; end

# source://avro//lib/avro/ipc.rb#73
Avro::IPC::BUFFER_HEADER_LENGTH = T.let(T.unsafe(nil), Integer)

# source://avro//lib/avro/ipc.rb#74
Avro::IPC::BUFFER_SIZE = T.let(T.unsafe(nil), Integer)

# source://avro//lib/avro/ipc.rb#466
class Avro::IPC::ConnectionClosedError < ::StandardError; end

# source://avro//lib/avro/ipc.rb#79
class Avro::IPC::ConnectionClosedException < ::Avro::AvroError; end

# source://avro//lib/avro/ipc.rb#503
class Avro::IPC::FramedReader
  # source://avro//lib/avro/ipc.rb#506
  def initialize(reader); end

  # source://avro//lib/avro/ipc.rb#510
  def read_framed_message; end

  # source://avro//lib/avro/ipc.rb#504
  def reader; end

  private

  # source://avro//lib/avro/ipc.rb#534
  def chunk_error?(chunk); end

  # source://avro//lib/avro/ipc.rb#528
  def read_buffer_size; end
end

# source://avro//lib/avro/ipc.rb#468
class Avro::IPC::FramedWriter
  # source://avro//lib/avro/ipc.rb#470
  def initialize(writer); end

  # source://avro//lib/avro/ipc.rb#489
  def to_s; end

  # source://avro//lib/avro/ipc.rb#474
  def write_framed_message(message); end

  # source://avro//lib/avro/ipc.rb#469
  def writer; end

  private

  # source://avro//lib/avro/ipc.rb#492
  def write_buffer(chunk); end

  # source://avro//lib/avro/ipc.rb#498
  def write_buffer_size(n); end
end

# source://avro//lib/avro/ipc.rb#56
Avro::IPC::HANDSHAKE_REQUESTOR_READER = T.let(T.unsafe(nil), Avro::IO::DatumReader)

# source://avro//lib/avro/ipc.rb#55
Avro::IPC::HANDSHAKE_REQUESTOR_WRITER = T.let(T.unsafe(nil), Avro::IO::DatumWriter)

# source://avro//lib/avro/ipc.rb#24
Avro::IPC::HANDSHAKE_REQUEST_SCHEMA = T.let(T.unsafe(nil), Avro::Schema::RecordSchema)

# source://avro//lib/avro/ipc.rb#58
Avro::IPC::HANDSHAKE_RESPONDER_READER = T.let(T.unsafe(nil), Avro::IO::DatumReader)

# source://avro//lib/avro/ipc.rb#57
Avro::IPC::HANDSHAKE_RESPONDER_WRITER = T.let(T.unsafe(nil), Avro::IO::DatumWriter)

# source://avro//lib/avro/ipc.rb#38
Avro::IPC::HANDSHAKE_RESPONSE_SCHEMA = T.let(T.unsafe(nil), Avro::Schema::RecordSchema)

# source://avro//lib/avro/ipc.rb#540
class Avro::IPC::HTTPTransceiver
  # source://avro//lib/avro/ipc.rb#542
  def initialize(host, port); end

  # source://avro//lib/avro/ipc.rb#541
  def host; end

  # source://avro//lib/avro/ipc.rb#541
  def port; end

  # source://avro//lib/avro/ipc.rb#541
  def remote_name; end

  # source://avro//lib/avro/ipc.rb#548
  def transceive(message); end
end

# source://avro//lib/avro/ipc.rb#62
Avro::IPC::META_READER = T.let(T.unsafe(nil), Avro::IO::DatumReader)

# source://avro//lib/avro/ipc.rb#60
Avro::IPC::META_SCHEMA = T.let(T.unsafe(nil), Avro::Schema::MapSchema)

# source://avro//lib/avro/ipc.rb#61
Avro::IPC::META_WRITER = T.let(T.unsafe(nil), Avro::IO::DatumWriter)

# source://avro//lib/avro/ipc.rb#68
Avro::IPC::REMOTE_HASHES = T.let(T.unsafe(nil), Hash)

# source://avro//lib/avro/ipc.rb#69
Avro::IPC::REMOTE_PROTOCOLS = T.let(T.unsafe(nil), Hash)

# source://avro//lib/avro/ipc.rb#82
class Avro::IPC::Requestor
  # source://avro//lib/avro/ipc.rb#86
  def initialize(local_protocol, transport); end

  # source://avro//lib/avro/ipc.rb#83
  def local_protocol; end

  # source://avro//lib/avro/ipc.rb#194
  def read_call_response(message_name, decoder); end

  # source://avro//lib/avro/ipc.rb#231
  def read_error(writers_schema, readers_schema, decoder); end

  # source://avro//lib/avro/ipc.rb#168
  def read_handshake_response(decoder); end

  # source://avro//lib/avro/ipc.rb#226
  def read_response(writers_schema, readers_schema, decoder); end

  # source://avro//lib/avro/ipc.rb#83
  def remote_hash; end

  # source://avro//lib/avro/ipc.rb#99
  def remote_hash=(new_remote_hash); end

  # source://avro//lib/avro/ipc.rb#83
  def remote_protocol; end

  # source://avro//lib/avro/ipc.rb#94
  def remote_protocol=(new_remote_protocol); end

  # source://avro//lib/avro/ipc.rb#104
  def request(message_name, request_datum); end

  # source://avro//lib/avro/ipc.rb#84
  def send_protocol; end

  # source://avro//lib/avro/ipc.rb#84
  def send_protocol=(_arg0); end

  # source://avro//lib/avro/ipc.rb#83
  def transport; end

  # source://avro//lib/avro/ipc.rb#143
  def write_call_request(message_name, request_datum, encoder); end

  # source://avro//lib/avro/ipc.rb#125
  def write_handshake_request(encoder); end

  # source://avro//lib/avro/ipc.rb#163
  def write_request(request_schema, request_datum, encoder); end
end

# source://avro//lib/avro/ipc.rb#238
class Avro::IPC::Responder
  # source://avro//lib/avro/ipc.rb#240
  def initialize(local_protocol); end

  # source://avro//lib/avro/ipc.rb#357
  def call(_local_message, _request); end

  # source://avro//lib/avro/ipc.rb#239
  def local_hash; end

  # source://avro//lib/avro/ipc.rb#239
  def local_protocol; end

  # source://avro//lib/avro/ipc.rb#310
  def process_handshake(decoder, encoder, connection = T.unsafe(nil)); end

  # source://avro//lib/avro/ipc.rb#239
  def protocol_cache; end

  # source://avro//lib/avro/ipc.rb#362
  def read_request(writers_schema, readers_schema, decoder); end

  # source://avro//lib/avro/ipc.rb#249
  def respond(call_request, transport = T.unsafe(nil)); end

  # source://avro//lib/avro/ipc.rb#372
  def write_error(writers_schema, error_exception, encoder); end

  # source://avro//lib/avro/ipc.rb#367
  def write_response(writers_schema, response_datum, encoder); end
end

# source://avro//lib/avro/ipc.rb#64
Avro::IPC::SYSTEM_ERROR_SCHEMA = T.let(T.unsafe(nil), Avro::Schema::UnionSchema)

# source://avro//lib/avro/ipc.rb#378
class Avro::IPC::SocketTransport
  # source://avro//lib/avro/ipc.rb#384
  def initialize(sock); end

  # source://avro//lib/avro/ipc.rb#461
  def close; end

  # source://avro//lib/avro/ipc.rb#389
  def is_connected?; end

  # source://avro//lib/avro/ipc.rb#382
  def protocol; end

  # source://avro//lib/avro/ipc.rb#382
  def protocol=(_arg0); end

  # source://avro//lib/avro/ipc.rb#453
  def read_buffer_length; end

  # source://avro//lib/avro/ipc.rb#398
  def read_framed_message; end

  # source://avro//lib/avro/ipc.rb#381
  def remote_name; end

  # source://avro//lib/avro/ipc.rb#381
  def sock; end

  # source://avro//lib/avro/ipc.rb#393
  def transceive(request); end

  # source://avro//lib/avro/ipc.rb#433
  def write_buffer(chunk); end

  # source://avro//lib/avro/ipc.rb#446
  def write_buffer_length(n); end

  # source://avro//lib/avro/ipc.rb#417
  def write_framed_message(message); end
end

# source://avro//lib/avro/logical_types.rb#24
module Avro::LogicalTypes
  class << self
    # source://avro//lib/avro/logical_types.rb#267
    def type_adapter(type, logical_type, schema = T.unsafe(nil)); end
  end
end

# source://avro//lib/avro/logical_types.rb#75
class Avro::LogicalTypes::BytesDecimal < ::Avro::LogicalTypes::LogicalTypeWithSchema
  # source://avro//lib/avro/logical_types.rb#99
  def initialize(schema); end

  # source://avro//lib/avro/logical_types.rb#133
  def decode(stream); end

  # source://avro//lib/avro/logical_types.rb#119
  def encode(value); end

  # source://avro//lib/avro/logical_types.rb#88
  def precision; end

  # source://avro//lib/avro/logical_types.rb#92
  def scale; end

  private

  # source://avro//lib/avro/logical_types.rb#146
  def from_byte_array(stream); end

  # source://avro//lib/avro/logical_types.rb#169
  def to_byte_array(number); end

  # source://avro//lib/avro/logical_types.rb#187
  def unscaled_value(decimal); end
end

# source://avro//lib/avro/logical_types.rb#76
Avro::LogicalTypes::BytesDecimal::ERROR_INSUFFICIENT_PRECISION = T.let(T.unsafe(nil), String)

# source://avro//lib/avro/logical_types.rb#77
Avro::LogicalTypes::BytesDecimal::ERROR_ROUNDING_NECESSARY = T.let(T.unsafe(nil), String)

# source://avro//lib/avro/logical_types.rb#78
Avro::LogicalTypes::BytesDecimal::ERROR_VALUE_MUST_BE_NUMERIC = T.let(T.unsafe(nil), String)

# source://avro//lib/avro/logical_types.rb#81
Avro::LogicalTypes::BytesDecimal::PACK_UNSIGNED_CHARS = T.let(T.unsafe(nil), String)

# source://avro//lib/avro/logical_types.rb#84
Avro::LogicalTypes::BytesDecimal::TEN = T.let(T.unsafe(nil), BigDecimal)

# source://avro//lib/avro/logical_types.rb#244
module Avro::LogicalTypes::Identity
  class << self
    # source://avro//lib/avro/logical_types.rb#249
    def decode(datum); end

    # source://avro//lib/avro/logical_types.rb#245
    def encode(datum); end
  end
end

# source://avro//lib/avro/logical_types.rb#202
module Avro::LogicalTypes::IntDate
  class << self
    # source://avro//lib/avro/logical_types.rb#211
    def decode(int); end

    # source://avro//lib/avro/logical_types.rb#205
    def encode(date); end
  end
end

# source://avro//lib/avro/logical_types.rb#203
Avro::LogicalTypes::IntDate::EPOCH_START = T.let(T.unsafe(nil), Date)

# source://avro//lib/avro/logical_types.rb#27
class Avro::LogicalTypes::LogicalTypeWithSchema
  # source://avro//lib/avro/logical_types.rb#40
  def initialize(schema); end

  # source://avro//lib/avro/logical_types.rb#64
  def decode(datum); end

  # source://avro//lib/avro/logical_types.rb#53
  def encode(datum); end

  # source://avro//lib/avro/logical_types.rb#30
  def schema; end
end

# source://avro//lib/avro/logical_types.rb#254
Avro::LogicalTypes::TYPES = T.let(T.unsafe(nil), Hash)

# source://avro//lib/avro/logical_types.rb#230
module Avro::LogicalTypes::TimestampMicros
  class << self
    # source://avro//lib/avro/logical_types.rb#238
    def decode(int); end

    # source://avro//lib/avro/logical_types.rb#231
    def encode(value); end
  end
end

# source://avro//lib/avro/logical_types.rb#216
module Avro::LogicalTypes::TimestampMillis
  class << self
    # source://avro//lib/avro/logical_types.rb#224
    def decode(int); end

    # source://avro//lib/avro/logical_types.rb#217
    def encode(value); end
  end
end

# source://avro//lib/avro/schema.rb#621
module Avro::Name
  class << self
    # source://avro//lib/avro/schema.rb#631
    def add_name(names, new_schema); end

    # source://avro//lib/avro/schema.rb#622
    def extract_namespace(name, namespace); end

    # source://avro//lib/avro/schema.rb#645
    def make_fullname(name, namespace); end
  end
end

# source://avro//lib/avro/protocol.rb#19
class Avro::Protocol
  # source://avro//lib/avro/protocol.rb#40
  def initialize(name, namespace = T.unsafe(nil), types = T.unsafe(nil), messages = T.unsafe(nil), doc = T.unsafe(nil)); end

  # source://avro//lib/avro/protocol.rb#67
  def ==(other); end

  # source://avro//lib/avro/protocol.rb#24
  def doc; end

  # source://avro//lib/avro/protocol.rb#24
  def md5; end

  # source://avro//lib/avro/protocol.rb#24
  def messages; end

  # source://avro//lib/avro/protocol.rb#24
  def name; end

  # source://avro//lib/avro/protocol.rb#24
  def namespace; end

  # source://avro//lib/avro/protocol.rb#63
  def to_s; end

  # source://avro//lib/avro/protocol.rb#24
  def types; end

  protected

  # source://avro//lib/avro/protocol.rb#104
  def to_avro(names = T.unsafe(nil)); end

  private

  # source://avro//lib/avro/protocol.rb#85
  def parse_messages(messages, names); end

  # source://avro//lib/avro/protocol.rb#72
  def parse_types(types, type_names); end

  class << self
    # source://avro//lib/avro/protocol.rb#25
    def parse(protocol_string); end
  end
end

# source://avro//lib/avro/protocol.rb#116
class Avro::Protocol::Message
  # source://avro//lib/avro/protocol.rb#119
  def initialize(name, request, response, errors = T.unsafe(nil), names = T.unsafe(nil), default_namespace = T.unsafe(nil), doc = T.unsafe(nil)); end

  # source://avro//lib/avro/protocol.rb#117
  def default_namespace; end

  # source://avro//lib/avro/protocol.rb#117
  def doc; end

  # source://avro//lib/avro/protocol.rb#117
  def errors; end

  # source://avro//lib/avro/protocol.rb#117
  def name; end

  # source://avro//lib/avro/protocol.rb#158
  def parse_errors(errors, names); end

  # source://avro//lib/avro/protocol.rb#142
  def parse_request(request, names); end

  # source://avro//lib/avro/protocol.rb#149
  def parse_response(response, names); end

  # source://avro//lib/avro/protocol.rb#117
  def request; end

  # source://avro//lib/avro/protocol.rb#117
  def response; end

  # source://avro//lib/avro/protocol.rb#128
  def to_avro(names = T.unsafe(nil)); end

  # source://avro//lib/avro/protocol.rb#138
  def to_s; end
end

# source://avro//lib/avro/protocol.rb#22
class Avro::Protocol::ProtocolParseError < ::Avro::AvroError; end

# source://avro//lib/avro/protocol.rb#20
Avro::Protocol::VALID_TYPE_SCHEMA_TYPES = T.let(T.unsafe(nil), Set)

# source://avro//lib/avro/protocol.rb#21
Avro::Protocol::VALID_TYPE_SCHEMA_TYPES_SYM = T.let(T.unsafe(nil), Set)

# source://avro//lib/avro/schema.rb#21
class Avro::Schema
  # source://avro//lib/avro/schema.rb#126
  def initialize(type, logical_type = T.unsafe(nil)); end

  # source://avro//lib/avro/schema.rb#209
  def ==(other, _seen = T.unsafe(nil)); end

  # source://avro//lib/avro/schema.rb#201
  def be_read?(other_schema); end

  # source://avro//lib/avro/schema.rb#170
  def crc_64_avro_fingerprint; end

  # source://avro//lib/avro/schema.rb#213
  def hash(_seen = T.unsafe(nil)); end

  # source://avro//lib/avro/schema.rb#159
  def initFPTable; end

  # source://avro//lib/avro/schema.rb#132
  def logical_type; end

  # source://avro//lib/avro/schema.rb#143
  def md5_fingerprint; end

  # source://avro//lib/avro/schema.rb#205
  def mutual_read?(other_schema); end

  # source://avro//lib/avro/schema.rb#197
  def read?(writers_schema); end

  # source://avro//lib/avro/schema.rb#149
  def sha256_fingerprint; end

  # source://avro//lib/avro/schema.rb#184
  def single_object_encoding_header; end

  # source://avro//lib/avro/schema.rb#187
  def single_object_schema_fingerprint; end

  # source://avro//lib/avro/schema.rb#217
  def subparse(json_obj, names = T.unsafe(nil), namespace = T.unsafe(nil)); end

  # source://avro//lib/avro/schema.rb#231
  def to_avro(_names = T.unsafe(nil)); end

  # source://avro//lib/avro/schema.rb#237
  def to_s; end

  # source://avro//lib/avro/schema.rb#136
  def type; end

  # source://avro//lib/avro/schema.rb#138
  def type_adapter; end

  # source://avro//lib/avro/schema.rb#131
  def type_sym; end

  private

  # source://avro//lib/avro/schema.rb#241
  def validate_aliases!; end

  class << self
    # source://avro//lib/avro/schema.rb#44
    def parse(json_string); end

    # source://avro//lib/avro/schema.rb#49
    def real_parse(json_obj, names = T.unsafe(nil), default_namespace = T.unsafe(nil)); end

    # source://avro//lib/avro/schema.rb#119
    def validate(expected_schema, logical_datum, options = T.unsafe(nil)); end
  end
end

# source://avro//lib/avro/schema.rb#371
class Avro::Schema::ArraySchema < ::Avro::Schema
  # source://avro//lib/avro/schema.rb#374
  def initialize(items, names = T.unsafe(nil), default_namespace = T.unsafe(nil)); end

  # source://avro//lib/avro/schema.rb#372
  def items; end

  # source://avro//lib/avro/schema.rb#379
  def to_avro(names = T.unsafe(nil)); end
end

# source://avro//lib/avro/schema.rb#486
class Avro::Schema::BytesSchema < ::Avro::Schema::PrimitiveSchema
  # source://avro//lib/avro/schema.rb#493
  def initialize(type, logical_type = T.unsafe(nil), precision = T.unsafe(nil), scale = T.unsafe(nil)); end

  # source://avro//lib/avro/schema.rb#511
  def match_schema?(schema); end

  # source://avro//lib/avro/schema.rb#491
  def precision; end

  # source://avro//lib/avro/schema.rb#491
  def scale; end

  # source://avro//lib/avro/schema.rb#502
  def to_avro(names = T.unsafe(nil)); end

  private

  # source://avro//lib/avro/schema.rb#523
  def validate_decimal!; end
end

# source://avro//lib/avro/schema.rb#488
Avro::Schema::BytesSchema::ERROR_INVALID_PRECISION = T.let(T.unsafe(nil), String)

# source://avro//lib/avro/schema.rb#487
Avro::Schema::BytesSchema::ERROR_INVALID_SCALE = T.let(T.unsafe(nil), String)

# source://avro//lib/avro/schema.rb#489
Avro::Schema::BytesSchema::ERROR_PRECISION_TOO_SMALL = T.let(T.unsafe(nil), String)

# source://avro//lib/avro/schema.rb#154
Avro::Schema::CRC_EMPTY = T.let(T.unsafe(nil), Integer)

# source://avro//lib/avro/schema.rb#42
Avro::Schema::DECIMAL_LOGICAL_TYPE = T.let(T.unsafe(nil), String)

# source://avro//lib/avro/schema.rb#40
Avro::Schema::DEFAULT_VALIDATE_OPTIONS = T.let(T.unsafe(nil), Hash)

# source://avro//lib/avro/schema.rb#424
class Avro::Schema::EnumSchema < ::Avro::Schema::NamedSchema
  # source://avro//lib/avro/schema.rb#429
  def initialize(name, space, symbols, names = T.unsafe(nil), doc = T.unsafe(nil), default = T.unsafe(nil), aliases = T.unsafe(nil)); end

  # source://avro//lib/avro/schema.rb#427
  def default; end

  # source://avro//lib/avro/schema.rb#427
  def doc; end

  # source://avro//lib/avro/schema.rb#427
  def symbols; end

  # source://avro//lib/avro/schema.rb#453
  def to_avro(_names = T.unsafe(nil)); end
end

# source://avro//lib/avro/schema.rb#425
Avro::Schema::EnumSchema::SYMBOL_REGEX = T.let(T.unsafe(nil), Regexp)

# source://avro//lib/avro/schema.rb#564
class Avro::Schema::Field < ::Avro::Schema
  # source://avro//lib/avro/schema.rb#567
  def initialize(type, name, default = T.unsafe(nil), order = T.unsafe(nil), names = T.unsafe(nil), namespace = T.unsafe(nil), doc = T.unsafe(nil), aliases = T.unsafe(nil)); end

  # source://avro//lib/avro/schema.rb#590
  def alias_names; end

  # source://avro//lib/avro/schema.rb#565
  def aliases; end

  # source://avro//lib/avro/schema.rb#565
  def default; end

  # source://avro//lib/avro/schema.rb#578
  def default?; end

  # source://avro//lib/avro/schema.rb#565
  def doc; end

  # source://avro//lib/avro/schema.rb#565
  def name; end

  # source://avro//lib/avro/schema.rb#565
  def order; end

  # source://avro//lib/avro/schema.rb#582
  def to_avro(names = T.unsafe(nil)); end

  # source://avro//lib/avro/schema.rb#565
  def type; end

  private

  # source://avro//lib/avro/schema.rb#596
  def validate_default!; end
end

# source://avro//lib/avro/schema.rb#530
class Avro::Schema::FixedSchema < ::Avro::Schema::NamedSchema
  # source://avro//lib/avro/schema.rb#532
  def initialize(name, space, size, names = T.unsafe(nil), logical_type = T.unsafe(nil), aliases = T.unsafe(nil), precision = T.unsafe(nil), scale = T.unsafe(nil)); end

  # source://avro//lib/avro/schema.rb#553
  def match_schema?(schema); end

  # source://avro//lib/avro/schema.rb#531
  def precision; end

  # source://avro//lib/avro/schema.rb#531
  def scale; end

  # source://avro//lib/avro/schema.rb#531
  def size; end

  # source://avro//lib/avro/schema.rb#543
  def to_avro(names = T.unsafe(nil)); end
end

# source://avro//lib/avro/schema.rb#36
Avro::Schema::INT_MAX_VALUE = T.let(T.unsafe(nil), Integer)

# source://avro//lib/avro/schema.rb#35
Avro::Schema::INT_MIN_VALUE = T.let(T.unsafe(nil), Integer)

# source://avro//lib/avro/schema.rb#38
Avro::Schema::LONG_MAX_VALUE = T.let(T.unsafe(nil), Integer)

# source://avro//lib/avro/schema.rb#37
Avro::Schema::LONG_MIN_VALUE = T.let(T.unsafe(nil), Integer)

# source://avro//lib/avro/schema.rb#384
class Avro::Schema::MapSchema < ::Avro::Schema
  # source://avro//lib/avro/schema.rb#387
  def initialize(values, names = T.unsafe(nil), default_namespace = T.unsafe(nil)); end

  # source://avro//lib/avro/schema.rb#392
  def to_avro(names = T.unsafe(nil)); end

  # source://avro//lib/avro/schema.rb#385
  def values; end
end

# source://avro//lib/avro/schema.rb#25
Avro::Schema::NAMED_TYPES = T.let(T.unsafe(nil), Set)

# source://avro//lib/avro/schema.rb#30
Avro::Schema::NAMED_TYPES_SYM = T.let(T.unsafe(nil), Set)

# source://avro//lib/avro/schema.rb#33
Avro::Schema::NAME_REGEX = T.let(T.unsafe(nil), Regexp)

# source://avro//lib/avro/schema.rb#251
class Avro::Schema::NamedSchema < ::Avro::Schema
  # source://avro//lib/avro/schema.rb#254
  def initialize(type, name, namespace = T.unsafe(nil), names = T.unsafe(nil), doc = T.unsafe(nil), logical_type = T.unsafe(nil), aliases = T.unsafe(nil)); end

  # source://avro//lib/avro/schema.rb#252
  def aliases; end

  # source://avro//lib/avro/schema.rb#276
  def fullname; end

  # source://avro//lib/avro/schema.rb#280
  def fullname_aliases; end

  # source://avro//lib/avro/schema.rb#288
  def match_fullname?(name); end

  # source://avro//lib/avro/schema.rb#292
  def match_schema?(schema); end

  # source://avro//lib/avro/schema.rb#252
  def name; end

  # source://avro//lib/avro/schema.rb#252
  def namespace; end

  # source://avro//lib/avro/schema.rb#263
  def to_avro(names = T.unsafe(nil)); end
end

# source://avro//lib/avro/schema.rb#24
Avro::Schema::PRIMITIVE_TYPES = T.let(T.unsafe(nil), Set)

# source://avro//lib/avro/schema.rb#29
Avro::Schema::PRIMITIVE_TYPES_SYM = T.let(T.unsafe(nil), Set)

# source://avro//lib/avro/schema.rb#464
class Avro::Schema::PrimitiveSchema < ::Avro::Schema
  # source://avro//lib/avro/schema.rb#465
  def initialize(type, logical_type = T.unsafe(nil)); end

  # source://avro//lib/avro/schema.rb#480
  def match_schema?(schema); end

  # source://avro//lib/avro/schema.rb#475
  def to_avro(names = T.unsafe(nil)); end
end

# source://avro//lib/avro/schema.rb#297
class Avro::Schema::RecordSchema < ::Avro::Schema::NamedSchema
  # source://avro//lib/avro/schema.rb#329
  def initialize(name, namespace, fields, names = T.unsafe(nil), schema_type = T.unsafe(nil), doc = T.unsafe(nil), aliases = T.unsafe(nil)); end

  # source://avro//lib/avro/schema.rb#298
  def doc; end

  # source://avro//lib/avro/schema.rb#298
  def fields; end

  # source://avro//lib/avro/schema.rb#349
  def fields_by_alias; end

  # source://avro//lib/avro/schema.rb#345
  def fields_hash; end

  # source://avro//lib/avro/schema.rb#359
  def to_avro(names = T.unsafe(nil)); end

  class << self
    # source://avro//lib/avro/schema.rb#300
    def make_field_objects(field_data, names, namespace = T.unsafe(nil)); end
  end
end

# source://avro//lib/avro/schema.rb#183
Avro::Schema::SINGLE_OBJECT_MAGIC_NUMBER = T.let(T.unsafe(nil), Array)

# source://avro//lib/avro/schema.rb#397
class Avro::Schema::UnionSchema < ::Avro::Schema
  # source://avro//lib/avro/schema.rb#400
  def initialize(schemas, names = T.unsafe(nil), default_namespace = T.unsafe(nil)); end

  # source://avro//lib/avro/schema.rb#398
  def schemas; end

  # source://avro//lib/avro/schema.rb#419
  def to_avro(names = T.unsafe(nil)); end
end

# source://avro//lib/avro/schema.rb#27
Avro::Schema::VALID_TYPES = T.let(T.unsafe(nil), Set)

# source://avro//lib/avro/schema.rb#31
Avro::Schema::VALID_TYPES_SYM = T.let(T.unsafe(nil), Set)

# source://avro//lib/avro/schema_compatibility.rb#18
module Avro::SchemaCompatibility
  class << self
    # source://avro//lib/avro/schema_compatibility.rb#24
    def can_read?(writers_schema, readers_schema); end

    # source://avro//lib/avro/schema_compatibility.rb#37
    def match_schemas(writers_schema, readers_schema); end

    # source://avro//lib/avro/schema_compatibility.rb#30
    def mutual_read?(writers_schema, readers_schema); end
  end
end

# source://avro//lib/avro/schema_compatibility.rb#86
class Avro::SchemaCompatibility::Checker
  # source://avro//lib/avro/schema_compatibility.rb#92
  def initialize; end

  # source://avro//lib/avro/schema_compatibility.rb#96
  def can_read?(writers_schema, readers_schema); end

  # source://avro//lib/avro/schema_compatibility.rb#100
  def mutual_read?(writers_schema, readers_schema); end

  private

  # source://avro//lib/avro/schema_compatibility.rb#106
  def full_match_schemas(writers_schema, readers_schema); end

  # source://avro//lib/avro/schema_compatibility.rb#147
  def match_record_schemas(writers_schema, readers_schema); end

  # source://avro//lib/avro/schema_compatibility.rb#136
  def match_union_schemas(writers_schema, readers_schema); end

  # source://avro//lib/avro/schema_compatibility.rb#169
  def recursion_in_progress?(writers_schema, readers_schema); end

  # source://avro//lib/avro/schema_compatibility.rb#89
  def recursion_set; end
end

# source://avro//lib/avro/schema_compatibility.rb#87
Avro::SchemaCompatibility::Checker::SIMPLE_CHECKS = T.let(T.unsafe(nil), Set)

# source://avro//lib/avro/schema_compatibility.rb#19
Avro::SchemaCompatibility::INT_COERCIBLE_TYPES_SYM = T.let(T.unsafe(nil), Array)

# source://avro//lib/avro/schema_compatibility.rb#20
Avro::SchemaCompatibility::LONG_COERCIBLE_TYPES_SYM = T.let(T.unsafe(nil), Array)

# source://avro//lib/avro/schema_normalization.rb#19
class Avro::SchemaNormalization
  # source://avro//lib/avro/schema_normalization.rb#24
  def initialize; end

  # source://avro//lib/avro/schema_normalization.rb#28
  def to_parsing_form(schema); end

  private

  # source://avro//lib/avro/schema_normalization.rb#71
  def normalize_field(field); end

  # source://avro//lib/avro/schema_normalization.rb#78
  def normalize_named_type(schema, attributes = T.unsafe(nil)); end

  # source://avro//lib/avro/schema_normalization.rb#34
  def normalize_schema(schema); end

  class << self
    # source://avro//lib/avro/schema_normalization.rb#20
    def to_parsing_form(schema); end
  end
end

# source://avro//lib/avro/schema.rb#610
class Avro::SchemaParseError < ::Avro::AvroError; end

# source://avro//lib/avro/schema_validator.rb#19
class Avro::SchemaValidator
  class << self
    # source://avro//lib/avro/schema_validator.rb#74
    def validate!(expected_schema, logical_datum, options = T.unsafe(nil)); end

    private

    # source://avro//lib/avro/schema_validator.rb#226
    def actual_value_message(value); end

    # source://avro//lib/avro/schema_validator.rb#220
    def deeper_path_for_hash(sub_key, path); end

    # source://avro//lib/avro/schema_validator.rb#168
    def enum_message(symbols, datum); end

    # source://avro//lib/avro/schema_validator.rb#208
    def first_compatible_type(datum, expected_schema, path, failures, options = T.unsafe(nil)); end

    # source://avro//lib/avro/schema_validator.rb#164
    def fixed_string_message(size, datum); end

    # source://avro//lib/avro/schema_validator.rb#150
    def resolve_datum(expected_schema, logical_datum, encoded); end

    # source://avro//lib/avro/schema_validator.rb#243
    def ruby_integer_to_avro_type(value); end

    # source://avro//lib/avro/schema_validator.rb#239
    def ruby_to_avro_type(ruby_class); end

    # source://avro//lib/avro/schema_validator.rb#172
    def validate_array(expected_schema, datum, path, result, options); end

    # source://avro//lib/avro/schema_validator.rb#179
    def validate_map(expected_schema, datum, path, result, options); end

    # source://avro//lib/avro/schema_validator.rb#87
    def validate_recursive(expected_schema, logical_datum, path, result, options); end

    # source://avro//lib/avro/schema_validator.rb#118
    def validate_simple(expected_schema, logical_datum, path, result, options); end

    # source://avro//lib/avro/schema_validator.rb#158
    def validate_type(expected_schema); end

    # source://avro//lib/avro/schema_validator.rb#190
    def validate_union(expected_schema, datum, path, result, options); end
  end
end

# source://avro//lib/avro/schema_validator.rb#25
Avro::SchemaValidator::BOOLEAN_VALUES = T.let(T.unsafe(nil), Array)

# source://avro//lib/avro/schema_validator.rb#24
Avro::SchemaValidator::COMPLEX_TYPES = T.let(T.unsafe(nil), Array)

# source://avro//lib/avro/schema_validator.rb#26
Avro::SchemaValidator::DEFAULT_VALIDATION_OPTIONS = T.let(T.unsafe(nil), Hash)

# source://avro//lib/avro/schema_validator.rb#22
Avro::SchemaValidator::INT_RANGE = T.let(T.unsafe(nil), Range)

# source://avro//lib/avro/schema_validator.rb#23
Avro::SchemaValidator::LONG_RANGE = T.let(T.unsafe(nil), Range)

# source://avro//lib/avro/schema_validator.rb#21
Avro::SchemaValidator::PATH_SEPARATOR = T.let(T.unsafe(nil), String)

# source://avro//lib/avro/schema_validator.rb#27
Avro::SchemaValidator::RECURSIVE_SIMPLE_VALIDATION_OPTIONS = T.let(T.unsafe(nil), Hash)

# source://avro//lib/avro/schema_validator.rb#20
Avro::SchemaValidator::ROOT_IDENTIFIER = T.let(T.unsafe(nil), String)

# source://avro//lib/avro/schema_validator.rb#28
Avro::SchemaValidator::RUBY_CLASS_TO_AVRO_TYPE = T.let(T.unsafe(nil), Hash)

# source://avro//lib/avro/schema_validator.rb#35
class Avro::SchemaValidator::Result
  # source://avro//lib/avro/schema_validator.rb#36
  def <<(error); end

  # source://avro//lib/avro/schema_validator.rb#40
  def add_error(path, message); end

  # source://avro//lib/avro/schema_validator.rb#52
  def errors; end

  # source://avro//lib/avro/schema_validator.rb#44
  def failure?; end

  # source://avro//lib/avro/schema_validator.rb#48
  def to_s; end
end

# source://avro//lib/avro/schema_validator.rb#71
class Avro::SchemaValidator::TypeMismatchError < ::Avro::SchemaValidator::ValidationError; end

# source://avro//lib/avro/schema_validator.rb#58
class Avro::SchemaValidator::ValidationError < ::StandardError
  # source://avro//lib/avro/schema_validator.rb#61
  def initialize(result = T.unsafe(nil)); end

  # source://avro//lib/avro/schema_validator.rb#59
  def result; end

  # source://avro//lib/avro/schema_validator.rb#66
  def to_s; end
end

# source://avro//lib/avro/schema.rb#612
class Avro::UnknownSchemaError < ::Avro::SchemaParseError
  # source://avro//lib/avro/schema.rb#615
  def initialize(type); end

  # source://avro//lib/avro/schema.rb#613
  def type_name; end
end

# source://avro//lib/avro.rb#26
Avro::VERSION = T.let(T.unsafe(nil), String)
