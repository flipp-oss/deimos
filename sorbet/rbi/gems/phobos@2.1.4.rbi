# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `phobos` gem.
# Please instead update this file by running `bin/tapioca gem phobos`.

# source://phobos//lib/phobos.rb#38
module Logging
  class << self
    # source://logging/2.3.1/lib/logging.rb#139
    def appenders; end

    # source://logging/2.3.1/lib/logging.rb#307
    def backtrace(b = T.unsafe(nil)); end

    # source://logging/2.3.1/lib/logging.rb#385
    def basepath; end

    # source://logging/2.3.1/lib/logging.rb#377
    def basepath=(path); end

    # source://logging/2.3.1/lib/logging.rb#363
    def cause_depth; end

    # source://logging/2.3.1/lib/logging.rb#354
    def cause_depth=(value); end

    # source://logging/2.3.1/lib/logging/diagnostic_context.rb#397
    def clear_diagnostic_contexts(all = T.unsafe(nil)); end

    # source://logging/2.3.1/lib/logging.rb#150
    def color_scheme(name, opts = T.unsafe(nil)); end

    # source://logging/2.3.1/lib/logging.rb#283
    def format_as(f); end

    # source://logging/2.3.1/lib/logging.rb#196
    def globally(name = T.unsafe(nil)); end

    # source://logging/2.3.1/lib/logging.rb#239
    def init(*args); end

    # source://logging/2.3.1/lib/logging.rb#566
    def initialized?; end

    # source://logging/2.3.1/lib/logging.rb#133
    def layouts; end

    # source://logging/2.3.1/lib/logging.rb#519
    def level_num(level); end

    # source://logging/2.3.1/lib/logging.rb#511
    def levelify(level); end

    # source://logging/2.3.1/lib/logging.rb#391
    def libpath(*args, &block); end

    # source://logging/2.3.1/lib/logging.rb#528
    def log_internal(level = T.unsafe(nil), &block); end

    # source://logging/2.3.1/lib/logging.rb#535
    def log_internal_error(err); end

    # source://logging/2.3.1/lib/logging.rb#72
    def logger(*args); end

    # source://logging/2.3.1/lib/logging/diagnostic_context.rb#379
    def mdc; end

    # source://logging/2.3.1/lib/logging/diagnostic_context.rb#386
    def ndc; end

    # source://logging/2.3.1/lib/logging.rb#408
    def path(*args, &block); end

    # source://logging/2.3.1/lib/logging.rb#500
    def raise_errors=(boolean); end

    # source://logging/2.3.1/lib/logging.rb#505
    def raise_errors?; end

    # source://logging/2.3.1/lib/logging.rb#162
    def reopen; end

    # source://logging/2.3.1/lib/logging.rb#549
    def reset; end

    # source://logging/2.3.1/lib/logging.rb#480
    def show_configuration(io = T.unsafe(nil), logger = T.unsafe(nil), indent = T.unsafe(nil)); end

    # source://logging/2.3.1/lib/logging.rb#541
    def shutdown(*args); end

    # source://logging/2.3.1/lib/logging.rb#342
    def utc_offset; end

    # source://logging/2.3.1/lib/logging.rb#332
    def utc_offset=(value); end

    # source://logging/2.3.1/lib/logging/version.rb#5
    def version; end
  end
end

# source://phobos//lib/phobos.rb#40
class Logging::Logger
  # source://logging/2.3.1/lib/logging/logger.rb#154
  def initialize(name); end

  # source://logging/2.3.1/lib/logging/logger.rb#185
  def <<(msg); end

  # source://logging/2.3.1/lib/logging/logger.rb#170
  def <=>(other); end

  # source://logging/2.3.1/lib/logging/logger.rb#472
  def _dump_configuration(indent = T.unsafe(nil)); end

  # source://logging/2.3.1/lib/logging/logger.rb#441
  def _meta_eval(code, file = T.unsafe(nil), line = T.unsafe(nil)); end

  # source://logging/2.3.1/lib/logging/logger.rb#452
  def _setup(name, opts = T.unsafe(nil)); end

  # source://logging/2.3.1/lib/logging/logger.rb#215
  def add(lvl, data = T.unsafe(nil), progname = T.unsafe(nil)); end

  # source://logging/2.3.1/lib/logging/logger.rb#349
  def add_appenders(*args); end

  # source://logging/2.3.1/lib/logging/logger.rb#130
  def additive; end

  # source://logging/2.3.1/lib/logging/logger.rb#238
  def additive=(val); end

  # source://logging/2.3.1/lib/logging/logger.rb#328
  def appenders; end

  # source://logging/2.3.1/lib/logging/logger.rb#338
  def appenders=(args); end

  # source://logging/2.3.1/lib/logging/logger.rb#130
  def caller_tracing; end

  # source://logging/2.3.1/lib/logging/logger.rb#253
  def caller_tracing=(val); end

  # source://logging/2.3.1/lib/logging/logger.rb#385
  def clear_appenders; end

  # source://phobos//lib/phobos.rb#42
  def formatter=(*args); end

  # source://logging/2.3.1/lib/logging/logger.rb#322
  def has_own_level?; end

  # source://logging/2.3.1/lib/logging/logger.rb#267
  def level; end

  # source://logging/2.3.1/lib/logging/logger.rb#300
  def level=(level); end

  # source://logging/2.3.1/lib/logging/logger.rb#130
  def name; end

  # source://logging/2.3.1/lib/logging/logger.rb#130
  def parent; end

  # source://phobos//lib/phobos.rb#48
  def pop_tags(*args); end

  # source://phobos//lib/phobos.rb#45
  def push_tags(*args); end

  # source://logging/2.3.1/lib/logging/logger.rb#366
  def remove_appenders(*args); end

  # source://logging/2.3.1/lib/logging/logger.rb#185
  def write(msg); end

  protected

  # source://logging/2.3.1/lib/logging/logger.rb#420
  def define_log_methods(force = T.unsafe(nil), code = T.unsafe(nil)); end

  # source://logging/2.3.1/lib/logging/logger.rb#405
  def log_event(event); end

  # source://logging/2.3.1/lib/logging/logger.rb#396
  def parent=(parent); end

  class << self
    # source://logging/2.3.1/lib/logging/logger.rb#43
    def [](name); end

    # source://logging/2.3.1/lib/logging/logger.rb#85
    def define_log_methods(logger); end

    def instantiate(*_arg0); end

    # source://logging/2.3.1/lib/logging/logger.rb#95
    def log_methods_for_level(level); end

    # source://logging/2.3.1/lib/logging/logger.rb#126
    def mutex; end

    # source://logging/2.3.1/lib/logging/logger.rb#38
    def new(*args); end

    # source://logging/2.3.1/lib/logging/logger.rb#28
    def root; end
  end
end

# source://phobos//lib/phobos/deep_struct.rb#6
# typed: strong
# Please use this with at least the same consideration as you would when using OpenStruct.
# Right now we only use this to parse our internal configuration files. It is not meant to
# be used on incoming data.
module Phobos
  extend ::Phobos::Configuration
  extend Phobos::Configuration

  class << self
    # source://phobos//lib/phobos.rb#64
    # _@param_ `configuration`
    sig { params(configuration: T::Hash[String, Object]).void }
    def add_listeners(configuration); end

    # source://phobos//lib/phobos.rb#56
    def config; end

    # _@param_ `configuration`
    sig { params(configuration: T.untyped).void }
    def configure(configuration); end

    sig { void }
    def configure_logger; end

    # source://phobos//lib/phobos.rb#81
    # _@param_ `backoff_config`
    sig { params(backoff_config: T.nilable(T::Hash[Symbol, Integer])).returns(T.untyped) }
    def create_exponential_backoff(backoff_config = T.unsafe(nil)); end

    # source://phobos//lib/phobos.rb#70
    # _@param_ `config_key`
    sig { params(config_key: T.nilable(String)).returns(T.untyped) }
    def create_kafka_client(config_key = T.unsafe(nil)); end

    # source://phobos//lib/phobos.rb#90
    # _@param_ `message`
    sig { params(message: String).void }
    def deprecate(message); end

    # source://phobos//lib/phobos.rb#58
    def logger; end

    # source://phobos//lib/phobos.rb#60
    def silence_log; end

    # source://phobos//lib/phobos.rb#60
    def silence_log=(_arg0); end
  end

  module Test
    module Helper
      sig do
        params(
          handler: T.untyped,
          payload: T.untyped,
          metadata: T.untyped,
          force_encoding: T.untyped
        ).returns(T.untyped)
      end
      def process_message(handler:, payload:, metadata: {}, force_encoding: nil); end

      GROUP = T.let("test-group", T.untyped)
      TOPIC = T.let("test-topic", T.untyped)
    end
  end
end

# source://phobos//lib/phobos/errors.rb#5
class Phobos::AbortError < ::Phobos::Error; end

# source://phobos//lib/phobos/actions/process_batch.rb#4
module Phobos::Actions; end

# source://phobos//lib/phobos/actions/process_batch.rb#5
class Phobos::Actions::ProcessBatch
  include ::Phobos::Instrumentation
  include ::Phobos::Log
  include Phobos::Instrumentation
  include Phobos::Log

  # source://phobos//lib/phobos/actions/process_batch.rb#11
  sig { params(listener: T.untyped, batch: T.untyped, listener_metadata: T.untyped).void }
  def initialize(listener:, batch:, listener_metadata:); end

  # source://phobos//lib/phobos/actions/process_batch.rb#22
  sig { returns(T.untyped) }
  def execute; end

  sig { params(event: T.untyped, extra: T.untyped).returns(T.untyped) }
  def instrument(event, extra = {}); end

  sig { params(msg: T.untyped, metadata: T.untyped).returns(T.untyped) }
  def log_debug(msg, metadata = {}); end

  sig { params(msg: T.untyped, metadata: T.untyped).returns(T.untyped) }
  def log_error(msg, metadata); end

  sig { params(msg: T.untyped, metadata: T.untyped).returns(T.untyped) }
  def log_info(msg, metadata = {}); end

  sig { params(msg: T.untyped, metadata: T.untyped).returns(T.untyped) }
  def log_warn(msg, metadata = {}); end

  # source://phobos//lib/phobos/actions/process_batch.rb#9
  def metadata; end
end

# source://phobos//lib/phobos/actions/process_batch_inline.rb#8
class Phobos::Actions::ProcessBatchInline
  include ::Phobos::Instrumentation
  include ::Phobos::Processor
  include Phobos::Processor

  # source://phobos//lib/phobos/actions/process_batch_inline.rb#13
  sig { params(listener: T.untyped, batch: T.untyped, metadata: T.untyped).void }
  def initialize(listener:, batch:, metadata:); end

  # source://phobos//lib/phobos/actions/process_batch_inline.rb#26
  sig { returns(T.untyped) }
  def execute; end

  sig { params(event: T.untyped, extra: T.untyped).returns(T.untyped) }
  def instrument(event, extra = {}); end

  # source://phobos//lib/phobos/actions/process_batch_inline.rb#11
  def metadata; end

  sig { params(interval: T.untyped).returns(T.untyped) }
  def snooze(interval); end

  private

  # source://phobos//lib/phobos/actions/process_batch_inline.rb#40
  def instantiate_batch_message(message); end

  # source://phobos//lib/phobos/actions/process_batch_inline.rb#50
  def process_batch(batch); end
end

# source://phobos//lib/phobos/actions/process_message.rb#7
class Phobos::Actions::ProcessMessage
  include ::Phobos::Instrumentation
  include ::Phobos::Processor
  include Phobos::Processor

  # source://phobos//lib/phobos/actions/process_message.rb#12
  sig { params(listener: T.untyped, message: T.untyped, listener_metadata: T.untyped).void }
  def initialize(listener:, message:, listener_metadata:); end

  # source://phobos//lib/phobos/actions/process_message.rb#24
  sig { returns(T.untyped) }
  def execute; end

  sig { params(event: T.untyped, extra: T.untyped).returns(T.untyped) }
  def instrument(event, extra = {}); end

  # source://phobos//lib/phobos/actions/process_message.rb#10
  def metadata; end

  sig { params(interval: T.untyped).returns(T.untyped) }
  def snooze(interval); end

  private

  # source://phobos//lib/phobos/actions/process_message.rb#38
  def process_message(payload); end
end

# source://phobos//lib/phobos/batch_handler.rb#4
module Phobos::BatchHandler
  mixes_in_class_methods ::Phobos::BatchHandler::ClassMethods

  # source://phobos//lib/phobos/batch_handler.rb#21
  # _@param_ `payloads`
  #
  # _@param_ `metadata`
  sig { params(payloads: T::Array[T.untyped], metadata: T::Hash[String, Object]).void }
  def around_consume_batch(payloads, metadata); end

  # source://phobos//lib/phobos/batch_handler.rb#13
  # _@param_ `_payloads`
  #
  # _@param_ `_metadata`
  sig { params(_payloads: T::Array[T.untyped], _metadata: T::Hash[String, Object]).void }
  def consume_batch(_payloads, _metadata); end

  class << self
    # source://phobos//lib/phobos/batch_handler.rb#6
    def included(base); end
  end
end

# source://phobos//lib/phobos/batch_handler.rb#25
module Phobos::BatchHandler::ClassMethods
  # source://phobos//lib/phobos/batch_handler.rb#28
  # _@param_ `kafka_client`
  sig { params(kafka_client: T.untyped).void }
  def start(kafka_client); end

  # source://phobos//lib/phobos/batch_handler.rb#31
  sig { void }
  def stop; end
end

# source://phobos//lib/phobos/batch_message.rb#4
class Phobos::BatchMessage
  # source://phobos//lib/phobos/batch_message.rb#22
  # _@param_ `key`
  #
  # _@param_ `partition`
  # _@param_ `offset`
  # _@param_ `payload`
  # _@param_ `headers`
  sig { params(key: T.untyped, partition: Integer, offset: Integer, payload: T.untyped, headers: T.untyped).void }
  def initialize(key:, partition:, offset:, payload:, headers:); end

  # source://phobos//lib/phobos/batch_message.rb#32
  # _@param_ `other`
  sig { params(other: Phobos::BatchMessage).returns(T::Boolean) }
  def ==(other); end

  # source://phobos//lib/phobos/batch_message.rb#14
  def headers; end

  # source://phobos//lib/phobos/batch_message.rb#14
  def headers=(_arg0); end

  # source://phobos//lib/phobos/batch_message.rb#6
  def key; end

  # source://phobos//lib/phobos/batch_message.rb#6
  def key=(_arg0); end

  # source://phobos//lib/phobos/batch_message.rb#10
  def offset; end

  # source://phobos//lib/phobos/batch_message.rb#10
  def offset=(_arg0); end

  # source://phobos//lib/phobos/batch_message.rb#8
  def partition; end

  # source://phobos//lib/phobos/batch_message.rb#8
  def partition=(_arg0); end

  # source://phobos//lib/phobos/batch_message.rb#12
  def payload; end

  # source://phobos//lib/phobos/batch_message.rb#12
  def payload=(_arg0); end
end

# source://phobos//lib/phobos/configuration.rb#6
module Phobos::Configuration
  # source://phobos//lib/phobos/configuration.rb#9
  # _@param_ `configuration`
  sig { params(configuration: T.untyped).void }
  def configure(configuration); end

  # source://phobos//lib/phobos/configuration.rb#22
  sig { void }
  def configure_logger; end

  private

  # source://phobos//lib/phobos/configuration.rb#55
  def configure_phobos_logger; end

  # source://phobos//lib/phobos/configuration.rb#64
  def configure_ruby_kafka_logger; end

  # source://phobos//lib/phobos/configuration.rb#36
  def fetch_configuration(configuration); end

  # source://phobos//lib/phobos/configuration.rb#91
  def json_layout; end

  # source://phobos//lib/phobos/configuration.rb#87
  def log_file; end

  # source://phobos//lib/phobos/configuration.rb#76
  def logger_appenders; end

  # source://phobos//lib/phobos/configuration.rb#40
  def read_configuration(configuration); end

  # source://phobos//lib/phobos/configuration.rb#95
  def stdout_layout; end
end

# source://phobos//lib/phobos/constants.rb#4
module Phobos::Constants; end

# source://phobos//lib/phobos/constants.rb#7
Phobos::Constants::KAFKA_CONSUMER_OPTS = T.let(T.unsafe(nil), Array)

# source://phobos//lib/phobos/constants.rb#15
Phobos::Constants::LISTENER_OPTS = T.let(T.unsafe(nil), Array)

# source://phobos//lib/phobos/constants.rb#5
Phobos::Constants::LOG_DATE_PATTERN = T.let(T.unsafe(nil), String)

# source://phobos//lib/phobos/deep_struct.rb#9
class Phobos::DeepStruct < ::OpenStruct
  # source://phobos//lib/phobos/deep_struct.rb#10
  # Based on
  # https://docs.omniref.com/ruby/2.3.0/files/lib/ostruct.rb#line=88
  sig { params(hash: T.untyped).void }
  def initialize(hash = T.unsafe(nil)); end

  # source://phobos//lib/phobos/deep_struct.rb#21
  sig { returns(T.untyped) }
  def to_h; end

  # source://phobos//lib/phobos/deep_struct.rb#21
  def to_hash; end

  private

  # source://phobos//lib/phobos/deep_struct.rb#28
  def to_deep_struct(value); end
end

# source://phobos//lib/phobos/echo_handler.rb#4
class Phobos::EchoHandler
  include ::Phobos::Handler
  extend ::Phobos::Handler::ClassMethods
  include Phobos::Handler

  sig { params(payload: T.untyped, metadata: T.untyped).returns(T.untyped) }
  def around_consume(payload, metadata); end

  # source://phobos//lib/phobos/echo_handler.rb#7
  sig { params(message: T.untyped, metadata: T.untyped).returns(T.untyped) }
  def consume(message, metadata); end
end

# source://phobos//lib/phobos/errors.rb#4
class Phobos::Error < ::StandardError; end

# source://phobos//lib/phobos/executor.rb#4
class Phobos::Executor
  include ::Phobos::Instrumentation
  include ::Phobos::Log
  include Phobos::Instrumentation
  include Phobos::Log

  # source://phobos//lib/phobos/executor.rb#8
  sig { void }
  def initialize; end

  sig { params(event: T.untyped, extra: T.untyped).returns(T.untyped) }
  def instrument(event, extra = {}); end

  sig { params(msg: T.untyped, metadata: T.untyped).returns(T.untyped) }
  def log_debug(msg, metadata = {}); end

  sig { params(msg: T.untyped, metadata: T.untyped).returns(T.untyped) }
  def log_error(msg, metadata); end

  sig { params(msg: T.untyped, metadata: T.untyped).returns(T.untyped) }
  def log_info(msg, metadata = {}); end

  sig { params(msg: T.untyped, metadata: T.untyped).returns(T.untyped) }
  def log_warn(msg, metadata = {}); end

  # source://phobos//lib/phobos/executor.rb#21
  sig { returns(T.untyped) }
  def start; end

  # source://phobos//lib/phobos/executor.rb#38
  sig { returns(T.untyped) }
  def stop; end

  private

  # source://phobos//lib/phobos/executor.rb#59
  def error_metadata(exception); end

  # source://phobos//lib/phobos/executor.rb#87
  def handle_crashed_listener(listener, error, retry_count); end

  # source://phobos//lib/phobos/executor.rb#68
  def run_listener(listener); end
end

# source://phobos//lib/phobos/handler.rb#4
module Phobos::Handler
  mixes_in_class_methods ::Phobos::Handler::ClassMethods

  # source://phobos//lib/phobos/handler.rb#14
  sig { params(payload: T.untyped, metadata: T.untyped).returns(T.untyped) }
  def around_consume(payload, metadata); end

  # source://phobos//lib/phobos/handler.rb#10
  sig { params(_payload: T.untyped, _metadata: T.untyped).returns(T.untyped) }
  def consume(_payload, _metadata); end

  class << self
    # source://phobos//lib/phobos/handler.rb#6
    def included(base); end
  end
end

# source://phobos//lib/phobos/handler.rb#18
module Phobos::Handler::ClassMethods
  # source://phobos//lib/phobos/handler.rb#19
  sig { params(kafka_client: T.untyped).returns(T.untyped) }
  def start(kafka_client); end

  # source://phobos//lib/phobos/handler.rb#21
  sig { returns(T.untyped) }
  def stop; end
end

# source://phobos//lib/phobos/instrumentation.rb#6
module Phobos::Instrumentation
  # source://phobos//lib/phobos/instrumentation.rb#19
  sig { params(event: T.untyped, extra: T.untyped).returns(T.untyped) }
  def instrument(event, extra = T.unsafe(nil)); end

  class << self
    # source://phobos//lib/phobos/instrumentation.rb#9
    sig { params(event: T.untyped).returns(T.untyped) }
    def subscribe(event); end

    # source://phobos//lib/phobos/instrumentation.rb#15
    sig { params(subscriber: T.untyped).returns(T.untyped) }
    def unsubscribe(subscriber); end
  end
end

# source://phobos//lib/phobos/instrumentation.rb#7
Phobos::Instrumentation::NAMESPACE = T.let(T.unsafe(nil), String)

# source://phobos//lib/phobos/listener.rb#5
# rubocop:disable Metrics/ParameterLists, Metrics/ClassLength
class Phobos::Listener
  include ::Phobos::Instrumentation
  include ::Phobos::Log
  include Phobos::Instrumentation
  include Phobos::Log

  # source://phobos//lib/phobos/listener.rb#35
  # rubocop:disable Metrics/MethodLength
  #
  # _@param_ `handler`
  # _@param_ `group_id`
  # _@param_ `topic`
  # _@param_ `min_bytes`
  # _@param_ `max_wait_time`
  # _@param_ `start_from_beginning`
  # _@param_ `delivery`
  # _@param_ `max_bytes_per_partition`
  # _@param_ `session_timeout`
  # _@param_ `offset_commit_interval`
  # _@param_ `heartbeat_interval`
  # _@param_ `offset_commit_threshold`
  # _@param_ `offset_retention_time`
  sig do
    params(
      handler: T.class_of(BasicObject),
      group_id: String,
      topic: String,
      min_bytes: T.nilable(Integer),
      max_wait_time: T.nilable(Integer),
      force_encoding: T.untyped,
      start_from_beginning: T::Boolean,
      backoff: T.untyped,
      delivery: String,
      max_bytes_per_partition: Integer,
      session_timeout: T.nilable(Integer),
      offset_commit_interval: T.nilable(Integer),
      heartbeat_interval: T.nilable(Integer),
      offset_commit_threshold: T.nilable(Integer),
      offset_retention_time: T.nilable(Integer)
    ).void
  end
  def initialize(handler:, group_id:, topic:, min_bytes: T.unsafe(nil), max_wait_time: T.unsafe(nil), force_encoding: T.unsafe(nil), start_from_beginning: T.unsafe(nil), backoff: T.unsafe(nil), delivery: T.unsafe(nil), max_bytes_per_partition: T.unsafe(nil), session_timeout: T.unsafe(nil), offset_commit_interval: T.unsafe(nil), heartbeat_interval: T.unsafe(nil), offset_commit_threshold: T.unsafe(nil), offset_retention_time: T.unsafe(nil)); end

  # source://phobos//lib/phobos/listener.rb#19
  def consumer; end

  # source://phobos//lib/phobos/listener.rb#94
  sig { returns(T.untyped) }
  def create_exponential_backoff; end

  # source://phobos//lib/phobos/listener.rb#19
  def encoding; end

  # source://phobos//lib/phobos/listener.rb#13
  def group_id; end

  # source://phobos//lib/phobos/listener.rb#18
  def handler_class; end

  # source://phobos//lib/phobos/listener.rb#16
  def id; end

  sig { params(event: T.untyped, extra: T.untyped).returns(T.untyped) }
  def instrument(event, extra = {}); end

  sig { params(msg: T.untyped, metadata: T.untyped).returns(T.untyped) }
  def log_debug(msg, metadata = {}); end

  sig { params(msg: T.untyped, metadata: T.untyped).returns(T.untyped) }
  def log_error(msg, metadata); end

  sig { params(msg: T.untyped, metadata: T.untyped).returns(T.untyped) }
  def log_info(msg, metadata = {}); end

  sig { params(msg: T.untyped, metadata: T.untyped).returns(T.untyped) }
  def log_warn(msg, metadata = {}); end

  # source://phobos//lib/phobos/listener.rb#102
  sig { returns(T.untyped) }
  def send_heartbeat_if_necessary; end

  # source://phobos//lib/phobos/listener.rb#98
  sig { returns(T::Boolean) }
  def should_stop?; end

  # source://phobos//lib/phobos/listener.rb#63
  sig { void }
  def start; end

  # source://phobos//lib/phobos/listener.rb#84
  sig { void }
  def stop; end

  # source://phobos//lib/phobos/listener.rb#15
  def topic; end

  private

  # source://phobos//lib/phobos/listener.rb#208
  def compact(hash); end

  # source://phobos//lib/phobos/listener.rb#158
  def consume_each_batch; end

  # source://phobos//lib/phobos/listener.rb#172
  def consume_each_batch_inline; end

  # source://phobos//lib/phobos/listener.rb#186
  def consume_each_message; end

  # source://phobos//lib/phobos/listener.rb#200
  def create_kafka_consumer; end

  # source://phobos//lib/phobos/listener.rb#110
  def listener_metadata; end

  # source://phobos//lib/phobos/listener.rb#146
  def start_consumer_loop; end

  # source://phobos//lib/phobos/listener.rb#114
  def start_listener; end

  # source://phobos//lib/phobos/listener.rb#130
  def stop_listener; end
end

# source://phobos//lib/phobos/listener.rb#9
Phobos::Listener::DEFAULT_MAX_BYTES_PER_PARTITION = T.let(T.unsafe(nil), Integer)

# source://phobos//lib/phobos/listener.rb#10
Phobos::Listener::DELIVERY_OPTS = T.let(T.unsafe(nil), Array)

# source://phobos//lib/phobos/log.rb#4
module Phobos::Log
  # source://phobos//lib/phobos/log.rb#9
  sig { params(msg: T.untyped, metadata: T.untyped).returns(T.untyped) }
  def log_debug(msg, metadata = T.unsafe(nil)); end

  # source://phobos//lib/phobos/log.rb#13
  sig { params(msg: T.untyped, metadata: T.untyped).returns(T.untyped) }
  def log_error(msg, metadata); end

  # source://phobos//lib/phobos/log.rb#5
  sig { params(msg: T.untyped, metadata: T.untyped).returns(T.untyped) }
  def log_info(msg, metadata = T.unsafe(nil)); end

  # source://phobos//lib/phobos/log.rb#17
  sig { params(msg: T.untyped, metadata: T.untyped).returns(T.untyped) }
  def log_warn(msg, metadata = T.unsafe(nil)); end
end

# source://phobos//lib/phobos/log.rb#22
module Phobos::LoggerHelper
  class << self
    # source://phobos//lib/phobos/log.rb#23
    sig { params(method: T.untyped, msg: T.untyped, metadata: T.untyped).returns(T.untyped) }
    def log(method, msg, metadata); end
  end
end

# source://phobos//lib/phobos/processor.rb#6
module Phobos::Processor
  include ::Phobos::Instrumentation
  extend ::ActiveSupport::Concern
  include Phobos::Instrumentation
  extend ActiveSupport::Concern

  sig { params(event: T.untyped, extra: T.untyped).returns(T.untyped) }
  def instrument(event, extra = {}); end

  # source://phobos//lib/phobos/processor.rb#12
  sig { params(interval: T.untyped).returns(T.untyped) }
  def snooze(interval); end

  private

  # source://phobos//lib/phobos/processor.rb#59
  def backoff; end

  # source://phobos//lib/phobos/processor.rb#63
  def backoff_interval; end

  # source://phobos//lib/phobos/processor.rb#26
  def force_encoding(value); end

  # source://phobos//lib/phobos/processor.rb#30
  def handle_error(error, instrumentation_key, error_message); end

  # source://phobos//lib/phobos/processor.rb#55
  def increment_retry_count; end

  # source://phobos//lib/phobos/processor.rb#51
  def retry_count; end
end

# source://phobos//lib/phobos/processor.rb#10
Phobos::Processor::MAX_SLEEP_INTERVAL = T.let(T.unsafe(nil), Integer)

# source://phobos//lib/phobos/producer.rb#4
module Phobos::Producer
  mixes_in_class_methods ::Phobos::Producer::ClassMethods

  # source://phobos//lib/phobos/producer.rb#11
  sig { returns(Phobos::Producer::PublicAPI) }
  def producer; end

  class << self
    # source://phobos//lib/phobos/producer.rb#6
    def included(base); end
  end
end

# source://phobos//lib/phobos/producer.rb#70
module Phobos::Producer::ClassMethods
  # source://phobos//lib/phobos/producer.rb#72
  sig { returns(Phobos::Producer::ClassMethods::PublicAPI) }
  def producer; end
end

# source://phobos//lib/phobos/producer.rb#76
class Phobos::Producer::ClassMethods::PublicAPI
  # source://phobos//lib/phobos/producer.rb#185
  sig { returns(T::Hash[T.untyped, T.untyped]) }
  def async_configs; end

  # source://phobos//lib/phobos/producer.rb#148
  sig { returns(Kafka::AsyncProducer) }
  def async_producer; end

  # source://phobos//lib/phobos/producer.rb#171
  sig { void }
  def async_producer_shutdown; end

  # source://phobos//lib/phobos/producer.rb#157
  # _@param_ `topic`
  #
  # _@param_ `payload`
  # _@param_ `partition_key`
  # _@param_ `headers`
  sig do
    params(
      topic: String,
      payload: String,
      key: T.untyped,
      partition_key: T.nilable(Integer),
      headers: T.nilable(T::Hash[T.untyped, T.untyped])
    ).void
  end
  def async_publish(topic:, payload:, key: T.unsafe(nil), partition_key: T.unsafe(nil), headers: T.unsafe(nil)); end

  # source://phobos//lib/phobos/producer.rb#164
  # _@param_ `messages`
  sig { params(messages: T::Array[T::Hash[T.untyped, T.untyped]]).void }
  def async_publish_list(messages); end

  # source://phobos//lib/phobos/producer.rb#89
  # This method configures the kafka client used with publish operations
  # performed by the host class
  #
  # _@param_ `kafka_client`
  sig { params(kafka_client: Kafka::Client).void }
  def configure_kafka_client(kafka_client); end

  # source://phobos//lib/phobos/producer.rb#141
  sig { returns(Kafka::AsyncProducer) }
  def create_async_producer; end

  # source://phobos//lib/phobos/producer.rb#100
  sig { returns(Kafka::Producer) }
  def create_sync_producer; end

  # source://phobos//lib/phobos/producer.rb#95
  sig { returns(Kafka::Client) }
  def kafka_client; end

  # source://phobos//lib/phobos/producer.rb#125
  # _@param_ `topic`
  #
  # _@param_ `payload`
  # _@param_ `partition_key`
  # _@param_ `headers`
  sig do
    params(
      topic: String,
      payload: String,
      key: T.untyped,
      partition_key: T.nilable(Integer),
      headers: T.nilable(T::Hash[T.untyped, T.untyped])
    ).void
  end
  def publish(topic:, payload:, key: T.unsafe(nil), partition_key: T.unsafe(nil), headers: T.unsafe(nil)); end

  # source://phobos//lib/phobos/producer.rb#132
  # _@param_ `messages`
  sig { params(messages: T::Array[T::Hash[T.untyped, T.untyped]]).void }
  def publish_list(messages); end

  # source://phobos//lib/phobos/producer.rb#178
  sig { returns(T::Hash[T.untyped, T.untyped]) }
  def regular_configs; end

  # source://phobos//lib/phobos/producer.rb#110
  sig { returns(Kafka::Producer) }
  def sync_producer; end

  # source://phobos//lib/phobos/producer.rb#115
  sig { void }
  def sync_producer_shutdown; end

  private

  # source://phobos//lib/phobos/producer.rb#202
  def async_automatic_delivery?; end

  # source://phobos//lib/phobos/producer.rb#192
  def produce_messages(producer, messages); end

  # source://phobos//lib/phobos/producer.rb#207
  def producer_store; end
end

# source://phobos//lib/phobos/producer.rb#80
Phobos::Producer::ClassMethods::PublicAPI::ASYNC_PRODUCER_PARAMS = T.let(T.unsafe(nil), Array)

# source://phobos//lib/phobos/producer.rb#82
Phobos::Producer::ClassMethods::PublicAPI::INTERNAL_PRODUCER_PARAMS = T.let(T.unsafe(nil), Array)

# source://phobos//lib/phobos/producer.rb#78
Phobos::Producer::ClassMethods::PublicAPI::NAMESPACE = T.let(T.unsafe(nil), Symbol)

# source://phobos//lib/phobos/producer.rb#15
class Phobos::Producer::PublicAPI
  # source://phobos//lib/phobos/producer.rb#16
  sig { params(host_obj: T.untyped).void }
  def initialize(host_obj); end

  # source://phobos//lib/phobos/producer.rb#40
  # _@param_ `topic`
  #
  # _@param_ `payload`
  # _@param_ `key`
  # _@param_ `partition_key`
  # _@param_ `headers`
  sig do
    params(
      topic: String,
      payload: String,
      key: T.nilable(String),
      partition_key: T.nilable(Integer),
      headers: T.nilable(T::Hash[T.untyped, T.untyped])
    ).void
  end
  def async_publish(topic:, payload:, key: T.unsafe(nil), partition_key: T.unsafe(nil), headers: T.unsafe(nil)); end

  # source://phobos//lib/phobos/producer.rb#59
  # _@param_ `messages`
  sig { params(messages: T::Array[T::Hash[T.untyped, T.untyped]]).returns(T.untyped) }
  def async_publish_list(messages); end

  # source://phobos//lib/phobos/producer.rb#26
  # _@param_ `topic`
  #
  # _@param_ `payload`
  # _@param_ `key`
  # _@param_ `partition_key`
  # _@param_ `headers`
  sig do
    params(
      topic: String,
      payload: String,
      key: T.nilable(String),
      partition_key: T.nilable(Integer),
      headers: T.nilable(T::Hash[T.untyped, T.untyped])
    ).void
  end
  def publish(topic:, payload:, key: T.unsafe(nil), partition_key: T.unsafe(nil), headers: T.unsafe(nil)); end

  # source://phobos//lib/phobos/producer.rb#54
  # _@param_ `messages` — e.g.: [   { topic: 'A', payload: 'message-1', key: '1', headers: { foo: 'bar' } },   { topic: 'B', payload: 'message-2', key: '2', headers: { foo: 'bar' } } ]
  sig { params(messages: T::Array[T::Hash[T.untyped, T.untyped]]).returns(T.untyped) }
  def publish_list(messages); end

  private

  # source://phobos//lib/phobos/producer.rb#65
  def class_producer; end
end

# source://phobos//lib/phobos/version.rb#5
Phobos::VERSION = T.let(T.unsafe(nil), String)
