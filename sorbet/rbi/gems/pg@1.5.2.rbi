# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `pg` gem.
# Please instead update this file by running `bin/tapioca gem pg`.

# source://pg//lib/pg.rb#6
module PG
  include ::PG::Constants

  class << self
    # source://pg//lib/pg.rb#62
    def connect(*args, &block); end

    def init_openssl(_arg0, _arg1); end
    def init_ssl(_arg0); end
    def is_threadsafe?; end
    def isthreadsafe; end
    def library_version; end

    # source://pg//lib/pg.rb#71
    def make_shareable(obj); end

    def threadsafe?; end

    # source://pg//lib/pg.rb#56
    def version_string(include_buildnum = T.unsafe(nil)); end
  end
end

class PG::ActiveSqlTransaction < ::PG::InvalidTransactionState; end
class PG::AdminShutdown < ::PG::OperatorIntervention; end
class PG::AmbiguousAlias < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::AmbiguousColumn < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::AmbiguousFunction < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::AmbiguousParameter < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::ArraySubscriptError < ::PG::DataException; end
class PG::AssertFailure < ::PG::PlpgsqlError; end
class PG::BadCopyFileFormat < ::PG::DataException; end

# source://pg//lib/pg/basic_type_map_based_on_result.rb#56
class PG::BasicTypeMapBasedOnResult < ::PG::TypeMapByOid
  include ::PG::BasicTypeRegistry::Checker

  # source://pg//lib/pg/basic_type_map_based_on_result.rb#59
  def initialize(connection_or_coder_maps, registry: T.unsafe(nil)); end
end

# source://pg//lib/pg/basic_type_map_for_queries.rb#36
class PG::BasicTypeMapForQueries < ::PG::TypeMapByClass
  include ::PG::BasicTypeRegistry::Checker

  # source://pg//lib/pg/basic_type_map_for_queries.rb#52
  def initialize(connection_or_coder_maps, registry: T.unsafe(nil), if_undefined: T.unsafe(nil)); end

  # source://pg//lib/pg/basic_type_map_for_queries.rb#90
  def encode_array_as; end

  # source://pg//lib/pg/basic_type_map_for_queries.rb#75
  def encode_array_as=(pg_type); end

  private

  # source://pg//lib/pg/basic_type_map_for_queries.rb#152
  def array_encoders_by_klass; end

  # source://pg//lib/pg/basic_type_map_for_queries.rb#100
  def coder_by_name(format, direction, name); end

  # source://pg//lib/pg/basic_type_map_for_queries.rb#159
  def get_array_type(value); end

  # source://pg//lib/pg/basic_type_map_for_queries.rb#94
  def init_encoders; end

  # source://pg//lib/pg/basic_type_map_for_queries.rb#109
  def populate_encoder_list; end

  # source://pg//lib/pg/basic_type_map_for_queries.rb#60
  def raise_undefined_type(oid_name, format); end

  # source://pg//lib/pg/basic_type_map_for_queries.rb#105
  def undefined(name, format); end
end

# source://pg//lib/pg/basic_type_map_for_queries.rb#37
class PG::BasicTypeMapForQueries::BinaryData < ::String; end

# source://pg//lib/pg/basic_type_map_for_queries.rb#187
PG::BasicTypeMapForQueries::DEFAULT_ARRAY_TYPE_MAP = T.let(T.unsafe(nil), Hash)

# source://pg//lib/pg/basic_type_map_for_queries.rb#169
PG::BasicTypeMapForQueries::DEFAULT_TYPE_MAP = T.let(T.unsafe(nil), Hash)

# source://pg//lib/pg/basic_type_map_for_queries.rb#40
class PG::BasicTypeMapForQueries::UndefinedEncoder < ::RuntimeError; end

# source://pg//lib/pg/basic_type_map_for_results.rb#70
class PG::BasicTypeMapForResults < ::PG::TypeMapByOid
  include ::PG::BasicTypeRegistry::Checker

  # source://pg//lib/pg/basic_type_map_for_results.rb#93
  def initialize(connection_or_coder_maps, registry: T.unsafe(nil)); end
end

# source://pg//lib/pg/basic_type_map_for_results.rb#73
class PG::BasicTypeMapForResults::WarningTypeMap < ::PG::TypeMapInRuby
  # source://pg//lib/pg/basic_type_map_for_results.rb#74
  def initialize(typenames); end

  # source://pg//lib/pg/basic_type_map_for_results.rb#79
  def typecast_result_value(result, _tuple, field); end
end

# source://pg//lib/pg/basic_type_registry.rb#28
class PG::BasicTypeRegistry
  include ::PG::BasicTypeRegistry::Checker

  # source://pg//lib/pg/basic_type_registry.rb#173
  def initialize; end

  # source://pg//lib/pg/basic_type_registry.rb#209
  def alias_type(format, new, old); end

  # source://pg//lib/pg/basic_type_registry.rb#181
  def coders_for(format, direction); end

  # source://pg//lib/pg/basic_type_registry.rb#222
  def define_default_types; end

  # source://pg//lib/pg/basic_type_registry.rb#190
  def register_coder(coder); end

  # source://pg//lib/pg/basic_type_registry.rb#222
  def register_default_types; end

  # source://pg//lib/pg/basic_type_registry.rb#202
  def register_type(format, name, encoder_class, decoder_class); end
end

# source://pg//lib/pg/basic_type_registry.rb#151
module PG::BasicTypeRegistry::Checker
  protected

  # source://pg//lib/pg/basic_type_registry.rb#161
  def build_coder_maps(conn_or_maps, registry: T.unsafe(nil)); end

  # source://pg//lib/pg/basic_type_registry.rb#156
  def check_format_and_direction(format, direction); end
end

# source://pg//lib/pg/basic_type_registry.rb#153
PG::BasicTypeRegistry::Checker::ValidDirections = T.let(T.unsafe(nil), Hash)

# source://pg//lib/pg/basic_type_registry.rb#152
PG::BasicTypeRegistry::Checker::ValidFormats = T.let(T.unsafe(nil), Hash)

# source://pg//lib/pg/basic_type_registry.rb#33
class PG::BasicTypeRegistry::CoderMap
  # source://pg//lib/pg/basic_type_registry.rb#45
  def initialize(result, coders_by_name, format, arraycoder); end

  # source://pg//lib/pg/basic_type_registry.rb#85
  def coder_by_name(name); end

  # source://pg//lib/pg/basic_type_registry.rb#89
  def coder_by_oid(oid); end

  # source://pg//lib/pg/basic_type_registry.rb#81
  def coders; end

  # source://pg//lib/pg/basic_type_registry.rb#83
  def coders_by_name; end

  # source://pg//lib/pg/basic_type_registry.rb#82
  def coders_by_oid; end
end

# source://pg//lib/pg/basic_type_registry.rb#36
PG::BasicTypeRegistry::CoderMap::DONT_QUOTE_TYPES = T.let(T.unsafe(nil), Hash)

# source://pg//lib/pg/basic_type_registry.rb#110
class PG::BasicTypeRegistry::CoderMapsBundle
  # source://pg//lib/pg/basic_type_registry.rb#113
  def initialize(connection, registry: T.unsafe(nil)); end

  # source://pg//lib/pg/basic_type_registry.rb#142
  def each_format(direction); end

  # source://pg//lib/pg/basic_type_registry.rb#146
  def map_for(format, direction); end

  # source://pg//lib/pg/basic_type_registry.rb#111
  def typenames_by_oid; end

  private

  # source://pg//lib/pg/basic_type_registry.rb#126
  def init_maps(registry, result); end
end

# source://pg//lib/pg/basic_type_registry.rb#297
PG::BasicTypeRegistry::DEFAULT_TYPE_REGISTRY = T.let(T.unsafe(nil), PG::BasicTypeRegistry)

# source://pg//lib/pg.rb#76
module PG::BinaryDecoder
  class << self
    private

    def init_date; end
  end
end

class PG::BinaryDecoder::Boolean < ::PG::SimpleDecoder
  include ::PG::Coder::BinaryFormatting

  def decode(*_arg0); end
end

PG::BinaryDecoder::Boolean::CFUNC = T.let(T.unsafe(nil), Object)

class PG::BinaryDecoder::Bytea < ::PG::SimpleDecoder
  include ::PG::Coder::BinaryFormatting

  def decode(*_arg0); end
end

PG::BinaryDecoder::Bytea::CFUNC = T.let(T.unsafe(nil), Object)

class PG::BinaryDecoder::CopyRow < ::PG::CopyDecoder
  include ::PG::Coder::BinaryFormatting

  def decode(*_arg0); end
end

PG::BinaryDecoder::CopyRow::CFUNC = T.let(T.unsafe(nil), Object)

class PG::BinaryDecoder::Date < ::PG::SimpleDecoder
  include ::PG::Coder::BinaryFormatting

  def decode(*_arg0); end
end

# source://pg//lib/pg/binary_decoder/date.rb#7
PG::BinaryDecoder::Date::CFUNC = T.let(T.unsafe(nil), Object)

class PG::BinaryDecoder::Float < ::PG::SimpleDecoder
  include ::PG::Coder::BinaryFormatting

  def decode(*_arg0); end
end

PG::BinaryDecoder::Float::CFUNC = T.let(T.unsafe(nil), Object)

class PG::BinaryDecoder::Integer < ::PG::SimpleDecoder
  include ::PG::Coder::BinaryFormatting

  def decode(*_arg0); end
end

PG::BinaryDecoder::Integer::CFUNC = T.let(T.unsafe(nil), Object)

class PG::BinaryDecoder::String < ::PG::SimpleDecoder
  include ::PG::Coder::BinaryFormatting

  def decode(*_arg0); end
end

PG::BinaryDecoder::String::CFUNC = T.let(T.unsafe(nil), Object)

class PG::BinaryDecoder::Timestamp < ::PG::SimpleDecoder
  include ::PG::Coder::BinaryFormatting

  def decode(*_arg0); end
end

PG::BinaryDecoder::Timestamp::CFUNC = T.let(T.unsafe(nil), Object)

# source://pg//lib/pg/binary_decoder/timestamp.rb#19
class PG::BinaryDecoder::TimestampLocal < ::PG::BinaryDecoder::Timestamp
  # source://pg//lib/pg/binary_decoder/timestamp.rb#20
  def initialize(hash = T.unsafe(nil), **kwargs); end
end

# source://pg//lib/pg/binary_decoder/timestamp.rb#7
class PG::BinaryDecoder::TimestampUtc < ::PG::BinaryDecoder::Timestamp
  # source://pg//lib/pg/binary_decoder/timestamp.rb#8
  def initialize(hash = T.unsafe(nil), **kwargs); end
end

# source://pg//lib/pg/binary_decoder/timestamp.rb#13
class PG::BinaryDecoder::TimestampUtcToLocal < ::PG::BinaryDecoder::Timestamp
  # source://pg//lib/pg/binary_decoder/timestamp.rb#14
  def initialize(hash = T.unsafe(nil), **kwargs); end
end

class PG::BinaryDecoder::ToBase64 < ::PG::CompositeDecoder
  include ::PG::Coder::BinaryFormatting

  def decode(*_arg0); end
end

PG::BinaryDecoder::ToBase64::CFUNC = T.let(T.unsafe(nil), Object)

# source://pg//lib/pg.rb#82
module PG::BinaryEncoder; end

class PG::BinaryEncoder::Boolean < ::PG::SimpleEncoder
  include ::PG::Coder::BinaryFormatting

  def encode(*_arg0); end
end

PG::BinaryEncoder::Boolean::CFUNC = T.let(T.unsafe(nil), Object)

class PG::BinaryEncoder::Bytea < ::PG::SimpleEncoder
  include ::PG::Coder::BinaryFormatting

  def encode(*_arg0); end
end

PG::BinaryEncoder::Bytea::CFUNC = T.let(T.unsafe(nil), Object)

class PG::BinaryEncoder::CopyRow < ::PG::CopyEncoder
  include ::PG::Coder::BinaryFormatting

  def encode(*_arg0); end
end

PG::BinaryEncoder::CopyRow::CFUNC = T.let(T.unsafe(nil), Object)

class PG::BinaryEncoder::Date < ::PG::SimpleEncoder
  include ::PG::Coder::BinaryFormatting

  def encode(*_arg0); end
end

PG::BinaryEncoder::Date::CFUNC = T.let(T.unsafe(nil), Object)

class PG::BinaryEncoder::Float4 < ::PG::SimpleEncoder
  include ::PG::Coder::BinaryFormatting

  def encode(*_arg0); end
end

PG::BinaryEncoder::Float4::CFUNC = T.let(T.unsafe(nil), Object)

class PG::BinaryEncoder::Float8 < ::PG::SimpleEncoder
  include ::PG::Coder::BinaryFormatting

  def encode(*_arg0); end
end

PG::BinaryEncoder::Float8::CFUNC = T.let(T.unsafe(nil), Object)

class PG::BinaryEncoder::FromBase64 < ::PG::CompositeEncoder
  include ::PG::Coder::BinaryFormatting

  def encode(*_arg0); end
end

PG::BinaryEncoder::FromBase64::CFUNC = T.let(T.unsafe(nil), Object)

class PG::BinaryEncoder::Int2 < ::PG::SimpleEncoder
  include ::PG::Coder::BinaryFormatting

  def encode(*_arg0); end
end

PG::BinaryEncoder::Int2::CFUNC = T.let(T.unsafe(nil), Object)

class PG::BinaryEncoder::Int4 < ::PG::SimpleEncoder
  include ::PG::Coder::BinaryFormatting

  def encode(*_arg0); end
end

PG::BinaryEncoder::Int4::CFUNC = T.let(T.unsafe(nil), Object)

class PG::BinaryEncoder::Int8 < ::PG::SimpleEncoder
  include ::PG::Coder::BinaryFormatting

  def encode(*_arg0); end
end

PG::BinaryEncoder::Int8::CFUNC = T.let(T.unsafe(nil), Object)

class PG::BinaryEncoder::String < ::PG::SimpleEncoder
  include ::PG::Coder::BinaryFormatting

  def encode(*_arg0); end
end

PG::BinaryEncoder::String::CFUNC = T.let(T.unsafe(nil), Object)

class PG::BinaryEncoder::Timestamp < ::PG::SimpleEncoder
  include ::PG::Coder::BinaryFormatting

  def encode(*_arg0); end
end

PG::BinaryEncoder::Timestamp::CFUNC = T.let(T.unsafe(nil), Object)

# source://pg//lib/pg/binary_encoder/timestamp.rb#13
class PG::BinaryEncoder::TimestampLocal < ::PG::BinaryEncoder::Timestamp
  # source://pg//lib/pg/binary_encoder/timestamp.rb#14
  def initialize(hash = T.unsafe(nil), **kwargs); end
end

# source://pg//lib/pg/binary_encoder/timestamp.rb#7
class PG::BinaryEncoder::TimestampUtc < ::PG::BinaryEncoder::Timestamp
  # source://pg//lib/pg/binary_encoder/timestamp.rb#8
  def initialize(hash = T.unsafe(nil), **kwargs); end
end

class PG::BranchTransactionAlreadyActive < ::PG::InvalidTransactionState; end
class PG::CannotCoerce < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::CannotConnectNow < ::PG::OperatorIntervention; end
class PG::CantChangeRuntimeParam < ::PG::ObjectNotInPrerequisiteState; end
class PG::CardinalityViolation < ::PG::ServerError; end
class PG::CaseNotFound < ::PG::ServerError; end
class PG::CharacterNotInRepertoire < ::PG::DataException; end
class PG::CheckViolation < ::PG::IntegrityConstraintViolation; end

# source://pg//lib/pg/coder.rb#6
class PG::Coder
  # source://pg//lib/pg/coder.rb#17
  def initialize(hash = T.unsafe(nil), **kwargs); end

  # source://pg//lib/pg/coder.rb#39
  def ==(v); end

  # source://pg//lib/pg/coder.rb#25
  def dup; end

  def flags; end
  def flags=(_arg0); end
  def format; end
  def format=(_arg0); end

  # source://pg//lib/pg/coder.rb#51
  def inspect; end

  # source://pg//lib/pg/coder.rb#60
  def inspect_short; end

  # source://pg//lib/pg/coder.rb#43
  def marshal_dump; end

  # source://pg//lib/pg/coder.rb#47
  def marshal_load(str); end

  def name; end
  def name=(_arg0); end
  def oid; end
  def oid=(_arg0); end

  # source://pg//lib/pg/coder.rb#30
  def to_h; end
end

# source://pg//lib/pg/coder.rb#8
module PG::Coder::BinaryFormatting
  # source://pg//lib/pg/coder.rb#9
  def initialize(hash = T.unsafe(nil), **kwargs); end
end

PG::Coder::FORMAT_ERROR_MASK = T.let(T.unsafe(nil), Integer)
PG::Coder::FORMAT_ERROR_TO_PARTIAL = T.let(T.unsafe(nil), Integer)
PG::Coder::FORMAT_ERROR_TO_RAISE = T.let(T.unsafe(nil), Integer)
PG::Coder::FORMAT_ERROR_TO_STRING = T.let(T.unsafe(nil), Integer)
PG::Coder::TIMESTAMP_APP_LOCAL = T.let(T.unsafe(nil), Integer)
PG::Coder::TIMESTAMP_APP_UTC = T.let(T.unsafe(nil), Integer)
PG::Coder::TIMESTAMP_DB_LOCAL = T.let(T.unsafe(nil), Integer)
PG::Coder::TIMESTAMP_DB_UTC = T.let(T.unsafe(nil), Integer)
class PG::CollationMismatch < ::PG::SyntaxErrorOrAccessRuleViolation; end

# source://pg//lib/pg/coder.rb#73
class PG::CompositeCoder < ::PG::Coder
  def delimiter; end
  def delimiter=(_arg0); end
  def elements_type; end
  def elements_type=(_arg0); end

  # source://pg//lib/pg/coder.rb#82
  def inspect; end

  def needs_quotation=(_arg0); end
  def needs_quotation?; end

  # source://pg//lib/pg/coder.rb#74
  def to_h; end
end

class PG::CompositeDecoder < ::PG::CompositeCoder; end
class PG::CompositeEncoder < ::PG::CompositeCoder; end
class PG::ConfigFileError < ::PG::ServerError; end
class PG::ConfigurationLimitExceeded < ::PG::InsufficientResources; end

# source://pg//lib/pg/connection.rb#30
class PG::Connection
  include ::PG::Constants

  # source://pg//lib/pg/connection.rb#582
  def async_cancel; end

  def async_describe_portal(_arg0); end
  def async_describe_prepared(_arg0); end

  # source://pg//lib/pg/connection.rb#555
  def async_encrypt_password(password, username, algorithm = T.unsafe(nil)); end

  def async_exec(*_arg0); end
  def async_exec_params(*_arg0); end
  def async_exec_prepared(*_arg0); end
  def async_flush; end

  # source://pg//lib/pg/connection.rb#423
  def async_get_copy_data(async = T.unsafe(nil), decoder = T.unsafe(nil)); end

  def async_get_last_result; end

  # source://pg//lib/pg/connection.rb#400
  def async_get_result; end

  # source://pg//lib/pg/connection.rb#471
  def async_isnonblocking; end

  def async_prepare(*_arg0); end

  # source://pg//lib/pg/connection.rb#495
  def async_put_copy_data(buffer, encoder = T.unsafe(nil)); end

  # source://pg//lib/pg/connection.rb#525
  def async_put_copy_end(*args); end

  def async_query(*_arg0); end

  # source://pg//lib/pg/connection.rb#567
  def async_reset; end

  def async_set_client_encoding(_arg0); end

  # source://pg//lib/pg/connection.rb#457
  def async_setnonblocking(enabled); end

  def backend_key; end
  def backend_pid; end
  def block(*_arg0); end

  # source://pg//lib/pg/connection.rb#582
  def cancel; end

  # source://pg//lib/pg/connection.rb#379
  def check_socket; end

  def client_encoding=(_arg0); end
  def close; end

  # source://pg//lib/pg/connection.rb#321
  def conndefaults; end

  # source://pg//lib/pg/connection.rb#337
  def conndefaults_hash; end

  def connect_poll; end
  def connection_needs_password; end
  def connection_used_password; end
  def conninfo; end

  # source://pg//lib/pg/connection.rb#345
  def conninfo_hash; end

  def consume_input; end

  # source://pg//lib/pg/connection.rb#211
  def copy_data(sql, coder = T.unsafe(nil)); end

  def db; end
  def decoder_for_get_copy_data; end
  def decoder_for_get_copy_data=(_arg0); end
  def describe_portal(_arg0); end
  def describe_prepared(_arg0); end
  def discard_results; end
  def encoder_for_put_copy_data; end
  def encoder_for_put_copy_data=(_arg0); end

  # source://pg//lib/pg/connection.rb#555
  def encrypt_password(password, username, algorithm = T.unsafe(nil)); end

  def enter_pipeline_mode; end
  def error_message; end
  def escape(_arg0); end
  def escape_bytea(_arg0); end
  def escape_identifier(_arg0); end
  def escape_literal(_arg0); end
  def escape_string(_arg0); end
  def exec(*_arg0); end
  def exec_params(*_arg0); end
  def exec_prepared(*_arg0); end
  def exit_pipeline_mode; end
  def external_encoding; end
  def field_name_type; end
  def field_name_type=(_arg0); end
  def finish; end
  def finished?; end
  def flush; end
  def get_client_encoding; end

  # source://pg//lib/pg/connection.rb#423
  def get_copy_data(async = T.unsafe(nil), decoder = T.unsafe(nil)); end

  def get_last_result; end

  # source://pg//lib/pg/connection.rb#400
  def get_result; end

  def host; end
  def hostaddr; end

  # source://pg//lib/pg/connection.rb#100
  def inspect; end

  def internal_encoding; end
  def internal_encoding=(_arg0); end
  def is_busy; end

  # source://pg//lib/pg/connection.rb#471
  def isnonblocking; end

  def lo_close(_arg0); end
  def lo_creat(*_arg0); end
  def lo_create(_arg0); end
  def lo_export(_arg0, _arg1); end
  def lo_import(_arg0); end
  def lo_lseek(_arg0, _arg1, _arg2); end
  def lo_open(*_arg0); end
  def lo_read(_arg0, _arg1); end
  def lo_seek(_arg0, _arg1, _arg2); end
  def lo_tell(_arg0); end
  def lo_truncate(_arg0, _arg1); end
  def lo_unlink(_arg0); end
  def lo_write(_arg0, _arg1); end
  def loclose(_arg0); end
  def locreat(*_arg0); end
  def locreate(_arg0); end
  def loexport(_arg0, _arg1); end
  def loimport(_arg0); end
  def lolseek(_arg0, _arg1, _arg2); end
  def loopen(*_arg0); end
  def loread(_arg0, _arg1); end
  def loseek(_arg0, _arg1, _arg2); end
  def lotell(_arg0); end
  def lotruncate(_arg0, _arg1); end
  def lounlink(_arg0); end
  def lowrite(_arg0, _arg1); end
  def make_empty_pgresult(_arg0); end

  # source://pg//lib/pg/connection.rb#471
  def nonblocking?; end

  def notifies; end
  def notifies_wait(*_arg0); end
  def options; end
  def parameter_status(_arg0); end
  def pass; end
  def pipeline_status; end
  def pipeline_sync; end
  def port; end
  def prepare(*_arg0); end
  def protocol_version; end

  # source://pg//lib/pg/connection.rb#495
  def put_copy_data(buffer, encoder = T.unsafe(nil)); end

  # source://pg//lib/pg/connection.rb#525
  def put_copy_end(*args); end

  def query(*_arg0); end
  def quote_ident(_arg0); end

  # source://pg//lib/pg/connection.rb#567
  def reset; end

  def reset_poll; end
  def reset_start; end
  def send_describe_portal(_arg0); end
  def send_describe_prepared(_arg0); end
  def send_flush_request; end
  def send_prepare(*_arg0); end
  def send_query(*_arg0); end
  def send_query_params(*_arg0); end
  def send_query_prepared(*_arg0); end
  def server_version; end
  def set_client_encoding(_arg0); end
  def set_default_encoding; end
  def set_error_context_visibility(_arg0); end
  def set_error_verbosity(_arg0); end
  def set_notice_processor; end
  def set_notice_receiver; end
  def set_single_row_mode; end

  # source://pg//lib/pg/connection.rb#457
  def setnonblocking(enabled); end

  def socket; end
  def socket_io; end
  def ssl_attribute(_arg0); end
  def ssl_attribute_names; end

  # source://pg//lib/pg/connection.rb#362
  def ssl_attributes; end

  def ssl_in_use?; end
  def status; end
  def sync_cancel; end
  def sync_describe_portal(_arg0); end
  def sync_describe_prepared(_arg0); end
  def sync_encrypt_password(*_arg0); end
  def sync_exec(*_arg0); end
  def sync_exec_params(*_arg0); end
  def sync_exec_prepared(*_arg0); end
  def sync_flush; end
  def sync_get_copy_data(*_arg0); end
  def sync_get_last_result; end
  def sync_get_result; end
  def sync_isnonblocking; end
  def sync_prepare(*_arg0); end
  def sync_put_copy_data(*_arg0); end
  def sync_put_copy_end(*_arg0); end
  def sync_reset; end
  def sync_set_client_encoding(_arg0); end
  def sync_setnonblocking(_arg0); end
  def trace(_arg0); end

  # source://pg//lib/pg/connection.rb#305
  def transaction; end

  def transaction_status; end
  def tty; end
  def type_map_for_queries; end
  def type_map_for_queries=(_arg0); end
  def type_map_for_results; end
  def type_map_for_results=(_arg0); end
  def unescape_bytea(_arg0); end
  def untrace; end
  def user; end
  def wait_for_notify(*_arg0); end

  private

  # source://pg//lib/pg/connection.rb#637
  def async_connect_or_reset(poll_meth); end

  def flush_data=(_arg0); end

  class << self
    # source://pg//lib/pg/connection.rb#937
    def async_api=(enable); end

    # source://pg//lib/pg/connection.rb#758
    def async_connect(*args); end

    # source://pg//lib/pg/connection.rb#858
    def async_ping(*args); end

    # source://pg//lib/pg/connection.rb#914
    def async_send_api=(enable); end

    def conndefaults; end

    # source://pg//lib/pg/connection.rb#329
    def conndefaults_hash; end

    # source://pg//lib/pg/connection.rb#758
    def connect(*args); end

    # source://pg//lib/pg/connection.rb#44
    def connect_hash_to_string(hash); end

    def connect_start(*_arg0); end
    def conninfo_parse(_arg0); end
    def encrypt_password(_arg0, _arg1); end
    def escape(_arg0); end
    def escape_bytea(_arg0); end
    def escape_string(_arg0); end
    def isthreadsafe; end

    # source://pg//lib/pg/connection.rb#758
    def new(*args); end

    # source://pg//lib/pg/connection.rb#758
    def open(*args); end

    # source://pg//lib/pg/connection.rb#64
    def parse_connect_args(*args); end

    # source://pg//lib/pg/connection.rb#858
    def ping(*args); end

    # source://pg//lib/pg/connection.rb#37
    def quote_connstr(value); end

    def quote_ident(_arg0); end

    # source://pg//lib/pg/connection.rb#758
    def setdb(*args); end

    # source://pg//lib/pg/connection.rb#758
    def setdblogin(*args); end

    def sync_connect(*_arg0); end
    def sync_ping(*_arg0); end
    def unescape_bytea(_arg0); end

    private

    # source://pg//lib/pg/connection.rb#776
    def connect_to_hosts(*args); end

    # source://pg//lib/pg/connection.rb#828
    def host_is_named_pipe?(host_string); end
  end
end

# source://pg//lib/pg/connection.rb#120
PG::Connection::BinarySignature = T.let(T.unsafe(nil), String)

# source://pg//lib/pg/connection.rb#33
PG::Connection::CONNECT_ARGUMENT_ORDER = T.let(T.unsafe(nil), Array)

# source://pg//lib/pg/connection.rb#49
PG::Connection::PROGRAM_NAME = T.let(T.unsafe(nil), String)

class PG::ConnectionBad < ::PG::Error; end
class PG::ConnectionDoesNotExist < ::PG::ConnectionException; end
class PG::ConnectionException < ::PG::ServerError; end
class PG::ConnectionFailure < ::PG::ConnectionException; end
module PG::Constants; end
PG::Constants::CONNECTION_AUTH_OK = T.let(T.unsafe(nil), Integer)
PG::Constants::CONNECTION_AWAITING_RESPONSE = T.let(T.unsafe(nil), Integer)
PG::Constants::CONNECTION_BAD = T.let(T.unsafe(nil), Integer)
PG::Constants::CONNECTION_CHECK_STANDBY = T.let(T.unsafe(nil), Integer)
PG::Constants::CONNECTION_CHECK_TARGET = T.let(T.unsafe(nil), Integer)
PG::Constants::CONNECTION_CHECK_WRITABLE = T.let(T.unsafe(nil), Integer)
PG::Constants::CONNECTION_CONSUME = T.let(T.unsafe(nil), Integer)
PG::Constants::CONNECTION_GSS_STARTUP = T.let(T.unsafe(nil), Integer)
PG::Constants::CONNECTION_MADE = T.let(T.unsafe(nil), Integer)
PG::Constants::CONNECTION_NEEDED = T.let(T.unsafe(nil), Integer)
PG::Constants::CONNECTION_OK = T.let(T.unsafe(nil), Integer)
PG::Constants::CONNECTION_SETENV = T.let(T.unsafe(nil), Integer)
PG::Constants::CONNECTION_SSL_STARTUP = T.let(T.unsafe(nil), Integer)
PG::Constants::CONNECTION_STARTED = T.let(T.unsafe(nil), Integer)
PG::Constants::DEF_PGPORT = T.let(T.unsafe(nil), Integer)
PG::Constants::INVALID_OID = T.let(T.unsafe(nil), Integer)
PG::Constants::INV_READ = T.let(T.unsafe(nil), Integer)
PG::Constants::INV_WRITE = T.let(T.unsafe(nil), Integer)
PG::Constants::InvalidOid = T.let(T.unsafe(nil), Integer)
PG::Constants::PGRES_BAD_RESPONSE = T.let(T.unsafe(nil), Integer)
PG::Constants::PGRES_COMMAND_OK = T.let(T.unsafe(nil), Integer)
PG::Constants::PGRES_COPY_BOTH = T.let(T.unsafe(nil), Integer)
PG::Constants::PGRES_COPY_IN = T.let(T.unsafe(nil), Integer)
PG::Constants::PGRES_COPY_OUT = T.let(T.unsafe(nil), Integer)
PG::Constants::PGRES_EMPTY_QUERY = T.let(T.unsafe(nil), Integer)
PG::Constants::PGRES_FATAL_ERROR = T.let(T.unsafe(nil), Integer)
PG::Constants::PGRES_NONFATAL_ERROR = T.let(T.unsafe(nil), Integer)
PG::Constants::PGRES_PIPELINE_ABORTED = T.let(T.unsafe(nil), Integer)
PG::Constants::PGRES_PIPELINE_SYNC = T.let(T.unsafe(nil), Integer)
PG::Constants::PGRES_POLLING_FAILED = T.let(T.unsafe(nil), Integer)
PG::Constants::PGRES_POLLING_OK = T.let(T.unsafe(nil), Integer)
PG::Constants::PGRES_POLLING_READING = T.let(T.unsafe(nil), Integer)
PG::Constants::PGRES_POLLING_WRITING = T.let(T.unsafe(nil), Integer)
PG::Constants::PGRES_SINGLE_TUPLE = T.let(T.unsafe(nil), Integer)
PG::Constants::PGRES_TUPLES_OK = T.let(T.unsafe(nil), Integer)
PG::Constants::PG_DIAG_COLUMN_NAME = T.let(T.unsafe(nil), Integer)
PG::Constants::PG_DIAG_CONSTRAINT_NAME = T.let(T.unsafe(nil), Integer)
PG::Constants::PG_DIAG_CONTEXT = T.let(T.unsafe(nil), Integer)
PG::Constants::PG_DIAG_DATATYPE_NAME = T.let(T.unsafe(nil), Integer)
PG::Constants::PG_DIAG_INTERNAL_POSITION = T.let(T.unsafe(nil), Integer)
PG::Constants::PG_DIAG_INTERNAL_QUERY = T.let(T.unsafe(nil), Integer)
PG::Constants::PG_DIAG_MESSAGE_DETAIL = T.let(T.unsafe(nil), Integer)
PG::Constants::PG_DIAG_MESSAGE_HINT = T.let(T.unsafe(nil), Integer)
PG::Constants::PG_DIAG_MESSAGE_PRIMARY = T.let(T.unsafe(nil), Integer)
PG::Constants::PG_DIAG_SCHEMA_NAME = T.let(T.unsafe(nil), Integer)
PG::Constants::PG_DIAG_SEVERITY = T.let(T.unsafe(nil), Integer)
PG::Constants::PG_DIAG_SEVERITY_NONLOCALIZED = T.let(T.unsafe(nil), Integer)
PG::Constants::PG_DIAG_SOURCE_FILE = T.let(T.unsafe(nil), Integer)
PG::Constants::PG_DIAG_SOURCE_FUNCTION = T.let(T.unsafe(nil), Integer)
PG::Constants::PG_DIAG_SOURCE_LINE = T.let(T.unsafe(nil), Integer)
PG::Constants::PG_DIAG_SQLSTATE = T.let(T.unsafe(nil), Integer)
PG::Constants::PG_DIAG_STATEMENT_POSITION = T.let(T.unsafe(nil), Integer)
PG::Constants::PG_DIAG_TABLE_NAME = T.let(T.unsafe(nil), Integer)
PG::Constants::PQERRORS_DEFAULT = T.let(T.unsafe(nil), Integer)
PG::Constants::PQERRORS_SQLSTATE = T.let(T.unsafe(nil), Integer)
PG::Constants::PQERRORS_TERSE = T.let(T.unsafe(nil), Integer)
PG::Constants::PQERRORS_VERBOSE = T.let(T.unsafe(nil), Integer)
PG::Constants::PQPING_NO_ATTEMPT = T.let(T.unsafe(nil), Integer)
PG::Constants::PQPING_NO_RESPONSE = T.let(T.unsafe(nil), Integer)
PG::Constants::PQPING_OK = T.let(T.unsafe(nil), Integer)
PG::Constants::PQPING_REJECT = T.let(T.unsafe(nil), Integer)
PG::Constants::PQSHOW_CONTEXT_ALWAYS = T.let(T.unsafe(nil), Integer)
PG::Constants::PQSHOW_CONTEXT_ERRORS = T.let(T.unsafe(nil), Integer)
PG::Constants::PQSHOW_CONTEXT_NEVER = T.let(T.unsafe(nil), Integer)
PG::Constants::PQTRANS_ACTIVE = T.let(T.unsafe(nil), Integer)
PG::Constants::PQTRANS_IDLE = T.let(T.unsafe(nil), Integer)
PG::Constants::PQTRANS_INERROR = T.let(T.unsafe(nil), Integer)
PG::Constants::PQTRANS_INTRANS = T.let(T.unsafe(nil), Integer)
PG::Constants::PQTRANS_UNKNOWN = T.let(T.unsafe(nil), Integer)
PG::Constants::PQ_PIPELINE_ABORTED = T.let(T.unsafe(nil), Integer)
PG::Constants::PQ_PIPELINE_OFF = T.let(T.unsafe(nil), Integer)
PG::Constants::PQ_PIPELINE_ON = T.let(T.unsafe(nil), Integer)
PG::Constants::SEEK_CUR = T.let(T.unsafe(nil), Integer)
PG::Constants::SEEK_END = T.let(T.unsafe(nil), Integer)
PG::Constants::SEEK_SET = T.let(T.unsafe(nil), Integer)

# source://pg//lib/pg/coder.rb#89
class PG::CopyCoder < ::PG::Coder
  def delimiter; end
  def delimiter=(_arg0); end
  def null_string; end
  def null_string=(_arg0); end

  # source://pg//lib/pg/coder.rb#90
  def to_h; end

  def type_map; end
  def type_map=(_arg0); end
end

class PG::CopyDecoder < ::PG::CopyCoder; end
class PG::CopyEncoder < ::PG::CopyCoder; end
class PG::CrashShutdown < ::PG::OperatorIntervention; end
class PG::DataCorrupted < ::PG::InternalError; end
class PG::DataException < ::PG::ServerError; end
class PG::DatabaseDropped < ::PG::OperatorIntervention; end
class PG::DatatypeMismatch < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::DatetimeFieldOverflow < ::PG::DataException; end
class PG::DependentObjectsStillExist < ::PG::DependentPrivilegeDescriptorsStillExist; end
class PG::DependentPrivilegeDescriptorsStillExist < ::PG::ServerError; end
class PG::DiagnosticsException < ::PG::ServerError; end
class PG::DiskFull < ::PG::InsufficientResources; end
class PG::DivisionByZero < ::PG::DataException; end
class PG::DuplicateAlias < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::DuplicateColumn < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::DuplicateCursor < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::DuplicateDatabase < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::DuplicateFile < ::PG::SystemError; end
class PG::DuplicateFunction < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::DuplicateJsonObjectKeyValue < ::PG::DataException; end
class PG::DuplicateObject < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::DuplicatePstatement < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::DuplicateSchema < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::DuplicateTable < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::EREContainingSqlNotPermitted < ::PG::ExternalRoutineException; end
class PG::EREModifyingSqlDataNotPermitted < ::PG::ExternalRoutineException; end
class PG::EREProhibitedSqlStatementAttempted < ::PG::ExternalRoutineException; end
class PG::EREReadingSqlDataNotPermitted < ::PG::ExternalRoutineException; end
class PG::ERIEEventTriggerProtocolViolated < ::PG::ExternalRoutineInvocationException; end
class PG::ERIEInvalidSqlstateReturned < ::PG::ExternalRoutineInvocationException; end
class PG::ERIENullValueNotAllowed < ::PG::ExternalRoutineInvocationException; end
class PG::ERIESrfProtocolViolated < ::PG::ExternalRoutineInvocationException; end
class PG::ERIETriggerProtocolViolated < ::PG::ExternalRoutineInvocationException; end
PG::ERROR_CLASSES = T.let(T.unsafe(nil), Hash)

# source://pg//lib/pg/exceptions.rb#9
class PG::Error < ::StandardError
  # source://pg//lib/pg/exceptions.rb#10
  def initialize(msg = T.unsafe(nil), connection: T.unsafe(nil), result: T.unsafe(nil)); end

  def connection; end
  def error; end
  def result; end
end

class PG::ErrorInAssignment < ::PG::DataException; end
class PG::EscapeCharacterConflict < ::PG::DataException; end
class PG::ExclusionViolation < ::PG::IntegrityConstraintViolation; end
class PG::ExternalRoutineException < ::PG::ServerError; end
class PG::ExternalRoutineInvocationException < ::PG::ServerError; end
class PG::FdwColumnNameNotFound < ::PG::FdwError; end
class PG::FdwDynamicParameterValueNeeded < ::PG::FdwError; end
class PG::FdwError < ::PG::ServerError; end
class PG::FdwFunctionSequenceError < ::PG::FdwError; end
class PG::FdwInconsistentDescriptorInformation < ::PG::FdwError; end
class PG::FdwInvalidAttributeValue < ::PG::FdwError; end
class PG::FdwInvalidColumnName < ::PG::FdwError; end
class PG::FdwInvalidColumnNumber < ::PG::FdwError; end
class PG::FdwInvalidDataType < ::PG::FdwError; end
class PG::FdwInvalidDataTypeDescriptors < ::PG::FdwError; end
class PG::FdwInvalidDescriptorFieldIdentifier < ::PG::FdwError; end
class PG::FdwInvalidHandle < ::PG::FdwError; end
class PG::FdwInvalidOptionIndex < ::PG::FdwError; end
class PG::FdwInvalidOptionName < ::PG::FdwError; end
class PG::FdwInvalidStringFormat < ::PG::FdwError; end
class PG::FdwInvalidStringLengthOrBufferLength < ::PG::FdwError; end
class PG::FdwInvalidUseOfNullPointer < ::PG::FdwError; end
class PG::FdwNoSchemas < ::PG::FdwError; end
class PG::FdwOptionNameNotFound < ::PG::FdwError; end
class PG::FdwOutOfMemory < ::PG::FdwError; end
class PG::FdwReplyHandle < ::PG::FdwError; end
class PG::FdwSchemaNotFound < ::PG::FdwError; end
class PG::FdwTableNotFound < ::PG::FdwError; end
class PG::FdwTooManyHandles < ::PG::FdwError; end
class PG::FdwUnableToCreateExecution < ::PG::FdwError; end
class PG::FdwUnableToCreateReply < ::PG::FdwError; end
class PG::FdwUnableToEstablishConnection < ::PG::FdwError; end
class PG::FeatureNotSupported < ::PG::ServerError; end
class PG::FloatingPointException < ::PG::DataException; end
class PG::ForeignKeyViolation < ::PG::IntegrityConstraintViolation; end
class PG::GeneratedAlways < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::GroupingError < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::HeldCursorRequiresSameIsolationLevel < ::PG::InvalidTransactionState; end
class PG::IdleInTransactionSessionTimeout < ::PG::InvalidTransactionState; end
class PG::IdleSessionTimeout < ::PG::OperatorIntervention; end
class PG::InFailedSqlTransaction < ::PG::InvalidTransactionState; end
class PG::InappropriateAccessModeForBranchTransaction < ::PG::InvalidTransactionState; end
class PG::InappropriateIsolationLevelForBranchTransaction < ::PG::InvalidTransactionState; end
class PG::IndeterminateCollation < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::IndeterminateDatatype < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::IndexCorrupted < ::PG::InternalError; end
class PG::IndicatorOverflow < ::PG::DataException; end
class PG::InsufficientPrivilege < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::InsufficientResources < ::PG::ServerError; end
class PG::IntegrityConstraintViolation < ::PG::ServerError; end
class PG::InternalError < ::PG::ServerError; end
class PG::IntervalFieldOverflow < ::PG::DataException; end
class PG::InvalidArgumentForLog < ::PG::DataException; end
class PG::InvalidArgumentForNthValue < ::PG::DataException; end
class PG::InvalidArgumentForNtile < ::PG::DataException; end
class PG::InvalidArgumentForPowerFunction < ::PG::DataException; end
class PG::InvalidArgumentForSqlJsonDatetimeFunction < ::PG::DataException; end
class PG::InvalidArgumentForWidthBucketFunction < ::PG::DataException; end
class PG::InvalidAuthorizationSpecification < ::PG::ServerError; end
class PG::InvalidBinaryRepresentation < ::PG::DataException; end
class PG::InvalidCatalogName < ::PG::ServerError; end
class PG::InvalidChangeOfResultFields < ::PG::Error; end
class PG::InvalidCharacterValueForCast < ::PG::DataException; end
class PG::InvalidColumnDefinition < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::InvalidColumnReference < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::InvalidCursorDefinition < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::InvalidCursorName < ::PG::ServerError; end
class PG::InvalidCursorState < ::PG::ServerError; end
class PG::InvalidDatabaseDefinition < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::InvalidDatetimeFormat < ::PG::DataException; end
class PG::InvalidEscapeCharacter < ::PG::DataException; end
class PG::InvalidEscapeOctet < ::PG::DataException; end
class PG::InvalidEscapeSequence < ::PG::DataException; end
class PG::InvalidForeignKey < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::InvalidFunctionDefinition < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::InvalidGrantOperation < ::PG::InvalidGrantor; end
class PG::InvalidGrantor < ::PG::ServerError; end
class PG::InvalidIndicatorParameterValue < ::PG::DataException; end
class PG::InvalidJsonText < ::PG::DataException; end
class PG::InvalidName < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::InvalidObjectDefinition < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::InvalidParameterValue < ::PG::DataException; end
class PG::InvalidPassword < ::PG::InvalidAuthorizationSpecification; end
class PG::InvalidPrecedingOrFollowingSize < ::PG::DataException; end
class PG::InvalidPstatementDefinition < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::InvalidRecursion < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::InvalidRegularExpression < ::PG::DataException; end
class PG::InvalidResultStatus < ::PG::Error; end
class PG::InvalidRoleSpecification < ::PG::ServerError; end
class PG::InvalidRowCountInLimitClause < ::PG::DataException; end
class PG::InvalidRowCountInResultOffsetClause < ::PG::DataException; end
class PG::InvalidSchemaDefinition < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::InvalidSchemaName < ::PG::ServerError; end
class PG::InvalidSqlJsonSubscript < ::PG::DataException; end
class PG::InvalidSqlStatementName < ::PG::ServerError; end
class PG::InvalidTableDefinition < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::InvalidTablesampleArgument < ::PG::DataException; end
class PG::InvalidTablesampleRepeat < ::PG::DataException; end
class PG::InvalidTextRepresentation < ::PG::DataException; end
class PG::InvalidTimeZoneDisplacementValue < ::PG::DataException; end
class PG::InvalidTransactionInitiation < ::PG::ServerError; end
class PG::InvalidTransactionState < ::PG::ServerError; end
class PG::InvalidTransactionTermination < ::PG::ServerError; end
class PG::InvalidUseOfEscapeCharacter < ::PG::DataException; end
class PG::InvalidXmlComment < ::PG::DataException; end
class PG::InvalidXmlContent < ::PG::DataException; end
class PG::InvalidXmlDocument < ::PG::DataException; end
class PG::InvalidXmlProcessingInstruction < ::PG::DataException; end
class PG::IoError < ::PG::SystemError; end
class PG::LEInvalidSpecification < ::PG::LocatorException; end
class PG::LocatorException < ::PG::ServerError; end
class PG::LockFileExists < ::PG::ConfigFileError; end
class PG::LockNotAvailable < ::PG::ObjectNotInPrerequisiteState; end

# source://pg//lib/pg/exceptions.rb#19
class PG::LostCopyState < ::PG::Error; end

class PG::MoreThanOneSqlJsonItem < ::PG::DataException; end
class PG::MostSpecificTypeMismatch < ::PG::DataException; end
class PG::NameTooLong < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::NoActiveSqlTransaction < ::PG::InvalidTransactionState; end
class PG::NoActiveSqlTransactionForBranchTransaction < ::PG::InvalidTransactionState; end
class PG::NoDataFound < ::PG::PlpgsqlError; end
class PG::NoResultError < ::PG::Error; end
class PG::NoSqlJsonItem < ::PG::DataException; end
class PG::NonNumericSqlJsonItem < ::PG::DataException; end
class PG::NonUniqueKeysInAJsonObject < ::PG::DataException; end
class PG::NonstandardUseOfEscapeCharacter < ::PG::DataException; end

# source://pg//lib/pg/exceptions.rb#17
class PG::NotAllCopyDataRetrieved < ::PG::Error; end

class PG::NotAnXmlDocument < ::PG::DataException; end

# source://pg//lib/pg/exceptions.rb#21
class PG::NotInBlockingMode < ::PG::Error; end

class PG::NotNullViolation < ::PG::IntegrityConstraintViolation; end
class PG::NullValueNoIndicatorParameter < ::PG::DataException; end
class PG::NullValueNotAllowed < ::PG::DataException; end
class PG::NumericValueOutOfRange < ::PG::DataException; end
class PG::ObjectInUse < ::PG::ObjectNotInPrerequisiteState; end
class PG::ObjectNotInPrerequisiteState < ::PG::ServerError; end
class PG::OperatorIntervention < ::PG::ServerError; end
class PG::OutOfMemory < ::PG::InsufficientResources; end

# source://pg//lib/pg/postgresql_lib_path.rb#2
PG::POSTGRESQL_LIB_PATH = T.let(T.unsafe(nil), String)

class PG::PlpgsqlError < ::PG::ServerError; end
class PG::ProgramLimitExceeded < ::PG::ServerError; end
class PG::ProtocolViolation < ::PG::ConnectionException; end
class PG::QueryCanceled < ::PG::OperatorIntervention; end
class PG::RaiseException < ::PG::PlpgsqlError; end
class PG::ReadOnlySqlTransaction < ::PG::InvalidTransactionState; end

# source://pg//lib/pg/coder.rb#99
class PG::RecordCoder < ::PG::Coder
  # source://pg//lib/pg/coder.rb#100
  def to_h; end

  def type_map; end
  def type_map=(_arg0); end
end

class PG::RecordDecoder < ::PG::RecordCoder; end
class PG::RecordEncoder < ::PG::RecordCoder; end
class PG::ReservedName < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::RestrictViolation < ::PG::IntegrityConstraintViolation; end

# source://pg//lib/pg/result.rb#7
class PG::Result
  include ::Enumerable
  include ::PG::Constants

  def [](_arg0); end
  def autoclear?; end
  def binary_tuples; end
  def check; end
  def check_result; end
  def clear; end
  def cleared?; end
  def cmd_status; end
  def cmd_tuples; end
  def cmdtuples; end
  def column_values(_arg0); end
  def each; end
  def each_row; end
  def error_field(_arg0); end
  def error_message; end
  def fformat(_arg0); end
  def field_name_type; end
  def field_name_type=(_arg0); end

  # source://pg//lib/pg/result.rb#26
  def field_names_as(type); end

  def field_values(_arg0); end
  def fields; end
  def fmod(_arg0); end
  def fname(_arg0); end
  def fnumber(_arg0); end
  def freeze; end
  def fsize(_arg0); end
  def ftable(_arg0); end
  def ftablecol(_arg0); end
  def ftype(_arg0); end
  def getisnull(_arg0, _arg1); end
  def getlength(_arg0, _arg1); end
  def getvalue(_arg0, _arg1); end

  # source://pg//lib/pg/result.rb#32
  def inspect; end

  # source://pg//lib/pg/result.rb#16
  def map_types!(type_map); end

  def nfields; end
  def nparams; end
  def ntuples; end
  def num_fields; end
  def num_tuples; end
  def oid_value; end
  def paramtype(_arg0); end
  def res_status(*_arg0); end
  def result_error_field(_arg0); end
  def result_error_message; end
  def result_status; end
  def result_verbose_error_message(_arg0, _arg1); end
  def stream_each; end
  def stream_each_row; end
  def stream_each_tuple; end
  def tuple(_arg0); end
  def tuple_values(_arg0); end
  def type_map; end
  def type_map=(_arg0); end
  def values; end
  def verbose_error_message(_arg0, _arg1); end

  class << self
    def res_status(_arg0); end
  end
end

class PG::SEInvalidSpecification < ::PG::SavepointException; end
class PG::SREFunctionExecutedNoReturnStatement < ::PG::SqlRoutineException; end
class PG::SREModifyingSqlDataNotPermitted < ::PG::SqlRoutineException; end
class PG::SREProhibitedSqlStatementAttempted < ::PG::SqlRoutineException; end
class PG::SREReadingSqlDataNotPermitted < ::PG::SqlRoutineException; end
class PG::SavepointException < ::PG::ServerError; end
class PG::SchemaAndDataStatementMixingNotSupported < ::PG::InvalidTransactionState; end
class PG::SequenceGeneratorLimitExceeded < ::PG::DataException; end
class PG::ServerError < ::PG::Error; end
class PG::SimpleCoder < ::PG::Coder; end
class PG::SimpleDecoder < ::PG::SimpleCoder; end
class PG::SimpleEncoder < ::PG::SimpleCoder; end
class PG::SingletonSqlJsonItemRequired < ::PG::DataException; end
class PG::SnapshotTooOld < ::PG::ServerError; end
class PG::SqlJsonArrayNotFound < ::PG::DataException; end
class PG::SqlJsonItemCannotBeCastToTargetType < ::PG::DataException; end
class PG::SqlJsonMemberNotFound < ::PG::DataException; end
class PG::SqlJsonNumberNotFound < ::PG::DataException; end
class PG::SqlJsonObjectNotFound < ::PG::DataException; end
class PG::SqlJsonScalarRequired < ::PG::DataException; end
class PG::SqlRoutineException < ::PG::ServerError; end
class PG::SqlStatementNotYetComplete < ::PG::ServerError; end
class PG::SqlclientUnableToEstablishSqlconnection < ::PG::ConnectionException; end
class PG::SqlserverRejectedEstablishmentOfSqlconnection < ::PG::ConnectionException; end
class PG::StackedDiagnosticsAccessedWithoutActiveHandler < ::PG::DiagnosticsException; end
class PG::StatementTooComplex < ::PG::ProgramLimitExceeded; end
class PG::StringDataLengthMismatch < ::PG::DataException; end
class PG::StringDataRightTruncation < ::PG::DataException; end
class PG::SubstringError < ::PG::DataException; end
class PG::SyntaxError < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::SyntaxErrorOrAccessRuleViolation < ::PG::ServerError; end
class PG::SystemError < ::PG::ServerError; end
class PG::TRDeadlockDetected < ::PG::TransactionRollback; end
class PG::TRIntegrityConstraintViolation < ::PG::TransactionRollback; end
class PG::TRSerializationFailure < ::PG::TransactionRollback; end
class PG::TRStatementCompletionUnknown < ::PG::TransactionRollback; end

# source://pg//lib/pg.rb#87
module PG::TextDecoder
  class << self
    private

    def init_inet; end
    def init_numeric; end
  end
end

class PG::TextDecoder::Array < ::PG::CompositeDecoder
  def decode(*_arg0); end
end

PG::TextDecoder::Array::CFUNC = T.let(T.unsafe(nil), Object)

class PG::TextDecoder::Boolean < ::PG::SimpleDecoder
  def decode(*_arg0); end
end

PG::TextDecoder::Boolean::CFUNC = T.let(T.unsafe(nil), Object)

class PG::TextDecoder::Bytea < ::PG::SimpleDecoder
  def decode(*_arg0); end
end

PG::TextDecoder::Bytea::CFUNC = T.let(T.unsafe(nil), Object)

class PG::TextDecoder::CopyRow < ::PG::CopyDecoder
  include ::PG::Coder::BinaryFormatting

  def decode(*_arg0); end
end

PG::TextDecoder::CopyRow::CFUNC = T.let(T.unsafe(nil), Object)

# source://pg//lib/pg/text_decoder/date.rb#8
class PG::TextDecoder::Date < ::PG::SimpleDecoder
  # source://pg//lib/pg/text_decoder/date.rb#9
  def decode(string, tuple = T.unsafe(nil), field = T.unsafe(nil)); end
end

class PG::TextDecoder::Float < ::PG::SimpleDecoder
  def decode(*_arg0); end
end

PG::TextDecoder::Float::CFUNC = T.let(T.unsafe(nil), Object)

class PG::TextDecoder::FromBase64 < ::PG::CompositeDecoder
  def decode(*_arg0); end
end

PG::TextDecoder::FromBase64::CFUNC = T.let(T.unsafe(nil), Object)

class PG::TextDecoder::Identifier < ::PG::SimpleDecoder
  def decode(*_arg0); end
end

PG::TextDecoder::Identifier::CFUNC = T.let(T.unsafe(nil), Object)

class PG::TextDecoder::Inet < ::PG::SimpleDecoder
  def decode(*_arg0); end
end

# source://pg//lib/pg/text_decoder/inet.rb#7
PG::TextDecoder::Inet::CFUNC = T.let(T.unsafe(nil), Object)

class PG::TextDecoder::Integer < ::PG::SimpleDecoder
  def decode(*_arg0); end
end

PG::TextDecoder::Integer::CFUNC = T.let(T.unsafe(nil), Object)

# source://pg//lib/pg/text_decoder/json.rb#8
class PG::TextDecoder::JSON < ::PG::SimpleDecoder
  # source://pg//lib/pg/text_decoder/json.rb#9
  def decode(string, tuple = T.unsafe(nil), field = T.unsafe(nil)); end
end

class PG::TextDecoder::Numeric < ::PG::SimpleDecoder
  def decode(*_arg0); end
end

# source://pg//lib/pg/text_decoder/numeric.rb#7
PG::TextDecoder::Numeric::CFUNC = T.let(T.unsafe(nil), Object)

class PG::TextDecoder::Record < ::PG::RecordDecoder
  def decode(*_arg0); end
end

PG::TextDecoder::Record::CFUNC = T.let(T.unsafe(nil), Object)

class PG::TextDecoder::String < ::PG::SimpleDecoder
  def decode(*_arg0); end
end

PG::TextDecoder::String::CFUNC = T.let(T.unsafe(nil), Object)

class PG::TextDecoder::Timestamp < ::PG::SimpleDecoder
  def decode(*_arg0); end
end

PG::TextDecoder::Timestamp::CFUNC = T.let(T.unsafe(nil), Object)

# source://pg//lib/pg/text_decoder/timestamp.rb#19
class PG::TextDecoder::TimestampLocal < ::PG::TextDecoder::Timestamp
  # source://pg//lib/pg/text_decoder/timestamp.rb#20
  def initialize(hash = T.unsafe(nil), **kwargs); end
end

# source://pg//lib/pg/text_decoder/timestamp.rb#7
class PG::TextDecoder::TimestampUtc < ::PG::TextDecoder::Timestamp
  # source://pg//lib/pg/text_decoder/timestamp.rb#8
  def initialize(hash = T.unsafe(nil), **kwargs); end
end

# source://pg//lib/pg/text_decoder/timestamp.rb#13
class PG::TextDecoder::TimestampUtcToLocal < ::PG::TextDecoder::Timestamp
  # source://pg//lib/pg/text_decoder/timestamp.rb#14
  def initialize(hash = T.unsafe(nil), **kwargs); end
end

# source://pg//lib/pg.rb#96
module PG::TextEncoder
  class << self
    private

    def init_numeric; end
  end
end

class PG::TextEncoder::Array < ::PG::CompositeEncoder
  def encode(*_arg0); end
end

PG::TextEncoder::Array::CFUNC = T.let(T.unsafe(nil), Object)

class PG::TextEncoder::Boolean < ::PG::SimpleEncoder
  def encode(*_arg0); end
end

PG::TextEncoder::Boolean::CFUNC = T.let(T.unsafe(nil), Object)

class PG::TextEncoder::Bytea < ::PG::SimpleEncoder
  def encode(*_arg0); end
end

PG::TextEncoder::Bytea::CFUNC = T.let(T.unsafe(nil), Object)

class PG::TextEncoder::CopyRow < ::PG::CopyEncoder
  include ::PG::Coder::BinaryFormatting

  def encode(*_arg0); end
end

PG::TextEncoder::CopyRow::CFUNC = T.let(T.unsafe(nil), Object)

# source://pg//lib/pg/text_encoder/date.rb#6
class PG::TextEncoder::Date < ::PG::SimpleEncoder
  # source://pg//lib/pg/text_encoder/date.rb#7
  def encode(value); end
end

class PG::TextEncoder::Float < ::PG::SimpleEncoder
  def encode(*_arg0); end
end

PG::TextEncoder::Float::CFUNC = T.let(T.unsafe(nil), Object)

class PG::TextEncoder::Identifier < ::PG::SimpleEncoder
  def encode(*_arg0); end
end

PG::TextEncoder::Identifier::CFUNC = T.let(T.unsafe(nil), Object)

# source://pg//lib/pg/text_encoder/inet.rb#8
class PG::TextEncoder::Inet < ::PG::SimpleEncoder
  # source://pg//lib/pg/text_encoder/inet.rb#9
  def encode(value); end
end

class PG::TextEncoder::Integer < ::PG::SimpleEncoder
  def encode(*_arg0); end
end

PG::TextEncoder::Integer::CFUNC = T.let(T.unsafe(nil), Object)

# source://pg//lib/pg/text_encoder/json.rb#8
class PG::TextEncoder::JSON < ::PG::SimpleEncoder
  # source://pg//lib/pg/text_encoder/json.rb#9
  def encode(value); end
end

class PG::TextEncoder::Numeric < ::PG::SimpleEncoder
  def encode(*_arg0); end
end

# source://pg//lib/pg/text_encoder/numeric.rb#7
PG::TextEncoder::Numeric::CFUNC = T.let(T.unsafe(nil), Object)

class PG::TextEncoder::QuotedLiteral < ::PG::CompositeEncoder
  def encode(*_arg0); end
end

PG::TextEncoder::QuotedLiteral::CFUNC = T.let(T.unsafe(nil), Object)

class PG::TextEncoder::Record < ::PG::RecordEncoder
  def encode(*_arg0); end
end

PG::TextEncoder::Record::CFUNC = T.let(T.unsafe(nil), Object)

class PG::TextEncoder::String < ::PG::SimpleEncoder
  def encode(*_arg0); end
end

PG::TextEncoder::String::CFUNC = T.let(T.unsafe(nil), Object)

# source://pg//lib/pg/text_encoder/timestamp.rb#12
class PG::TextEncoder::TimestampUtc < ::PG::SimpleEncoder
  # source://pg//lib/pg/text_encoder/timestamp.rb#13
  def encode(value); end
end

# source://pg//lib/pg/text_encoder/timestamp.rb#18
class PG::TextEncoder::TimestampWithTimeZone < ::PG::SimpleEncoder
  # source://pg//lib/pg/text_encoder/timestamp.rb#19
  def encode(value); end
end

# source://pg//lib/pg/text_encoder/timestamp.rb#6
class PG::TextEncoder::TimestampWithoutTimeZone < ::PG::SimpleEncoder
  # source://pg//lib/pg/text_encoder/timestamp.rb#7
  def encode(value); end
end

class PG::TextEncoder::ToBase64 < ::PG::CompositeEncoder
  def encode(*_arg0); end
end

PG::TextEncoder::ToBase64::CFUNC = T.let(T.unsafe(nil), Object)
class PG::TooManyArguments < ::PG::ProgramLimitExceeded; end
class PG::TooManyColumns < ::PG::ProgramLimitExceeded; end
class PG::TooManyConnections < ::PG::InsufficientResources; end
class PG::TooManyJsonArrayElements < ::PG::DataException; end
class PG::TooManyJsonObjectMembers < ::PG::DataException; end
class PG::TooManyRows < ::PG::PlpgsqlError; end
class PG::TransactionResolutionUnknown < ::PG::ConnectionException; end
class PG::TransactionRollback < ::PG::ServerError; end
class PG::TriggeredActionException < ::PG::ServerError; end
class PG::TriggeredDataChangeViolation < ::PG::ServerError; end
class PG::TrimError < ::PG::DataException; end

# source://pg//lib/pg/tuple.rb#7
class PG::Tuple
  include ::Enumerable

  def [](_arg0); end
  def each; end

  # source://pg//lib/pg/tuple.rb#23
  def each_key(&block); end

  def each_value; end
  def fetch(*_arg0); end

  # source://pg//lib/pg/tuple.rb#14
  def has_key?(key); end

  def index(_arg0); end

  # source://pg//lib/pg/tuple.rb#10
  def inspect; end

  # source://pg//lib/pg/tuple.rb#14
  def key?(key); end

  # source://pg//lib/pg/tuple.rb#19
  def keys; end

  def length; end
  def size; end
  def values; end

  private

  def field_map; end
  def field_names; end
  def marshal_dump; end
  def marshal_load(_arg0); end
end

class PG::TypeMap; end

module PG::TypeMap::DefaultTypeMappable
  def default_type_map; end
  def default_type_map=(_arg0); end
  def with_default_type_map(_arg0); end
end

class PG::TypeMapAllStrings < ::PG::TypeMap; end

class PG::TypeMapByClass < ::PG::TypeMap
  include ::PG::TypeMap::DefaultTypeMappable

  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def coders; end
end

# source://pg//lib/pg/type_map_by_column.rb#6
class PG::TypeMapByColumn < ::PG::TypeMap
  include ::PG::TypeMap::DefaultTypeMappable

  def initialize(_arg0); end

  def coders; end

  # source://pg//lib/pg/type_map_by_column.rb#12
  def inspect; end

  # source://pg//lib/pg/type_map_by_column.rb#8
  def oids; end
end

class PG::TypeMapByMriType < ::PG::TypeMap
  include ::PG::TypeMap::DefaultTypeMappable

  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def coders; end
end

class PG::TypeMapByOid < ::PG::TypeMap
  include ::PG::TypeMap::DefaultTypeMappable

  def add_coder(_arg0); end
  def build_column_map(_arg0); end
  def coders; end
  def max_rows_for_online_lookup; end
  def max_rows_for_online_lookup=(_arg0); end
  def rm_coder(_arg0, _arg1); end
end

class PG::TypeMapInRuby < ::PG::TypeMap
  include ::PG::TypeMap::DefaultTypeMappable

  def typecast_copy_get(_arg0, _arg1, _arg2, _arg3); end
  def typecast_query_param(_arg0, _arg1); end
  def typecast_result_value(_arg0, _arg1, _arg2); end
end

class PG::UnableToSend < ::PG::Error; end
class PG::UndefinedColumn < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::UndefinedFile < ::PG::SystemError; end
class PG::UndefinedFunction < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::UndefinedObject < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::UndefinedParameter < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::UndefinedTable < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::UniqueViolation < ::PG::IntegrityConstraintViolation; end
class PG::UnsafeNewEnumValueUsage < ::PG::ObjectNotInPrerequisiteState; end
class PG::UnterminatedCString < ::PG::DataException; end
class PG::UntranslatableCharacter < ::PG::DataException; end
class PG::WindowingError < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::WithCheckOptionViolation < ::PG::ServerError; end
class PG::WrongObjectType < ::PG::SyntaxErrorOrAccessRuleViolation; end
class PG::ZeroLengthCharacterString < ::PG::DataException; end
