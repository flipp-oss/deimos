# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `logging` gem.
# Please instead update this file by running `bin/tapioca gem logging`.

# source://logging//lib/logging/utils.rb#70
class File < ::IO
  # source://logging//lib/logging/utils.rb#84
  def flock?; end

  # source://logging//lib/logging/utils.rb#100
  def flock_sh; end
end

# source://logging//lib/logging/utils.rb#120
module FileUtils
  private

  # source://logging//lib/logging/utils.rb#126
  def concat(src, dest); end

  class << self
    # source://logging//lib/logging/utils.rb#126
    def concat(src, dest); end
  end
end

# source://logging//lib/logging.rb#11
HAVE_SYSLOG = T.let(T.unsafe(nil), TrueClass)

# source://logging//lib/logging.rb#18
module Logging
  extend ::LittlePlugger
  extend ::LittlePlugger::ClassMethods

  class << self
    # source://logging//lib/logging.rb#139
    def appenders; end

    # source://logging//lib/logging.rb#307
    def backtrace(b = T.unsafe(nil)); end

    # source://logging//lib/logging.rb#385
    def basepath; end

    # source://logging//lib/logging.rb#377
    def basepath=(path); end

    # source://logging//lib/logging.rb#363
    def cause_depth; end

    # source://logging//lib/logging.rb#354
    def cause_depth=(value); end

    # source://logging//lib/logging/diagnostic_context.rb#397
    def clear_diagnostic_contexts(all = T.unsafe(nil)); end

    # source://logging//lib/logging.rb#150
    def color_scheme(name, opts = T.unsafe(nil)); end

    # source://logging//lib/logging.rb#283
    def format_as(f); end

    # source://logging//lib/logging.rb#196
    def globally(name = T.unsafe(nil)); end

    # source://logging//lib/logging.rb#239
    def init(*args); end

    # source://logging//lib/logging.rb#566
    def initialized?; end

    # source://logging//lib/logging.rb#133
    def layouts; end

    # source://logging//lib/logging.rb#519
    def level_num(level); end

    # source://logging//lib/logging.rb#511
    def levelify(level); end

    # source://logging//lib/logging.rb#391
    def libpath(*args, &block); end

    # source://logging//lib/logging.rb#528
    def log_internal(level = T.unsafe(nil), &block); end

    # source://logging//lib/logging.rb#535
    def log_internal_error(err); end

    # source://logging//lib/logging.rb#72
    def logger(*args); end

    # source://logging//lib/logging/diagnostic_context.rb#379
    def mdc; end

    # source://logging//lib/logging/diagnostic_context.rb#386
    def ndc; end

    # source://logging//lib/logging.rb#408
    def path(*args, &block); end

    # source://logging//lib/logging.rb#500
    def raise_errors=(boolean); end

    # source://logging//lib/logging.rb#505
    def raise_errors?; end

    # source://logging//lib/logging.rb#162
    def reopen; end

    # source://logging//lib/logging.rb#549
    def reset; end

    # source://logging//lib/logging.rb#480
    def show_configuration(io = T.unsafe(nil), logger = T.unsafe(nil), indent = T.unsafe(nil)); end

    # source://logging//lib/logging.rb#541
    def shutdown(*args); end

    # source://logging//lib/logging.rb#342
    def utc_offset; end

    # source://logging//lib/logging.rb#332
    def utc_offset=(value); end

    # source://logging//lib/logging/version.rb#5
    def version; end
  end
end

# source://logging//lib/logging/appender.rb#12
class Logging::Appender
  # source://logging//lib/logging/appender.rb#32
  def initialize(name, opts = T.unsafe(nil)); end

  # source://logging//lib/logging/appender.rb#91
  def <<(str); end

  def _to_s; end

  # source://logging//lib/logging/appender.rb#180
  def add_filters(*args); end

  # source://logging//lib/logging/appender.rb#289
  def allow(event); end

  # source://logging//lib/logging/appender.rb#66
  def append(event); end

  # source://logging//lib/logging/appender.rb#199
  def close(footer = T.unsafe(nil)); end

  # source://logging//lib/logging/appender.rb#226
  def closed?; end

  # source://logging//lib/logging/appender.rb#263
  def encoding; end

  # source://logging//lib/logging/appender.rb#274
  def encoding=(value); end

  # source://logging//lib/logging/appender.rb#14
  def filters; end

  # source://logging//lib/logging/appender.rb#168
  def filters=(args); end

  # source://logging//lib/logging/appender.rb#245
  def flush; end

  # source://logging//lib/logging/appender.rb#14
  def layout; end

  # source://logging//lib/logging/appender.rb#154
  def layout=(layout); end

  # source://logging//lib/logging/appender.rb#14
  def level; end

  # source://logging//lib/logging/appender.rb#133
  def level=(level); end

  # source://logging//lib/logging/appender.rb#14
  def name; end

  # source://logging//lib/logging/appender.rb#303
  def off?; end

  # source://logging//lib/logging/appender.rb#234
  def reopen; end

  # source://logging//lib/logging/appender.rb#257
  def to_s; end

  private

  # source://logging//lib/logging/appender.rb#318
  def write(event); end
end

# source://logging//lib/logging/appenders.rb#3
module Logging::Appenders
  extend ::Logging::Appenders

  # source://logging//lib/logging/appenders.rb#11
  def [](name); end

  # source://logging//lib/logging/appenders.rb#19
  def []=(name, value); end

  # source://logging//lib/logging/appenders.rb#34
  def each(&block); end

  # source://logging//lib/logging/appenders.rb#27
  def remove(name); end

  # source://logging//lib/logging/appenders.rb#40
  def reset; end

  class << self
    # source://logging//lib/logging/appenders/file.rb#5
    def file(*args); end

    # source://logging//lib/logging/appenders/io.rb#5
    def io(*args); end

    # source://logging//lib/logging/appenders/rolling_file.rb#4
    def rolling_file(*args); end

    # source://logging//lib/logging/appenders/console.rb#76
    def stderr(*args); end

    # source://logging//lib/logging/appenders/console.rb#68
    def stdout(*args); end

    # source://logging//lib/logging/appenders/string_io.rb#6
    def string_io(*args); end

    # source://logging//lib/logging/appenders/syslog.rb#11
    def syslog(*args); end
  end
end

# source://logging//lib/logging/appenders/buffering.rb#14
module Logging::Appenders::Buffering
  # source://logging//lib/logging/appenders/buffering.rb#42
  def initialize(*args, &block); end

  # source://logging//lib/logging/appenders/buffering.rb#32
  def async; end

  # source://logging//lib/logging/appenders/buffering.rb#232
  def async=(bool); end

  def async?; end

  # source://logging//lib/logging/appenders/buffering.rb#24
  def auto_flushing; end

  # source://logging//lib/logging/appenders/buffering.rb#160
  def auto_flushing=(period); end

  # source://logging//lib/logging/appenders/buffering.rb#20
  def buffer; end

  # source://logging//lib/logging/appenders/buffering.rb#102
  def clear!; end

  # source://logging//lib/logging/appenders/buffering.rb#55
  def close(*args); end

  # source://logging//lib/logging/appenders/buffering.rb#78
  def flush; end

  # source://logging//lib/logging/appenders/buffering.rb#28
  def flush_period; end

  # source://logging//lib/logging/appenders/buffering.rb#201
  def flush_period=(period); end

  # source://logging//lib/logging/appenders/buffering.rb#223
  def flush_period?; end

  # source://logging//lib/logging/appenders/buffering.rb#122
  def immediate_at=(level); end

  # source://logging//lib/logging/appenders/buffering.rb#71
  def reopen; end

  # source://logging//lib/logging/appenders/buffering.rb#37
  def write_size; end

  # source://logging//lib/logging/appenders/buffering.rb#37
  def write_size=(_arg0); end

  protected

  # source://logging//lib/logging/appenders/buffering.rb#247
  def configure_buffering(opts); end

  # source://logging//lib/logging/appenders/buffering.rb#259
  def immediate?(event); end

  private

  # source://logging//lib/logging/appenders/buffering.rb#318
  def _parse_hours_minutes_seconds(str); end

  # source://logging//lib/logging/appenders/buffering.rb#337
  def _parse_numeric(str); end

  # source://logging//lib/logging/appenders/buffering.rb#347
  def _setup_async_flusher; end

  # source://logging//lib/logging/appenders/buffering.rb#279
  def write(event); end
end

# source://logging//lib/logging/appenders/buffering.rb#372
class Logging::Appenders::Buffering::AsyncFlusher
  # source://logging//lib/logging/appenders/buffering.rb#381
  def initialize(appender, period); end

  # source://logging//lib/logging/appenders/buffering.rb#453
  def immediate?; end

  # source://logging//lib/logging/appenders/buffering.rb#433
  def signal(immediate = T.unsafe(nil)); end

  # source://logging//lib/logging/appenders/buffering.rb#396
  def start; end

  # source://logging//lib/logging/appenders/buffering.rb#417
  def stop; end

  # source://logging//lib/logging/appenders/buffering.rb#447
  def waiting?; end

  private

  # source://logging//lib/logging/appenders/buffering.rb#459
  def _try_to_sleep; end

  # source://logging//lib/logging/appenders/buffering.rb#465
  def _wait_for_signal; end
end

# source://logging//lib/logging/appenders/buffering.rb#17
Logging::Appenders::Buffering::DEFAULT_BUFFER_SIZE = T.let(T.unsafe(nil), Integer)

# source://logging//lib/logging/appenders/console.rb#6
class Logging::Appenders::Console < ::Logging::Appenders::IO
  # source://logging//lib/logging/appenders/console.rb#23
  def initialize(*args); end

  # source://logging//lib/logging/appenders/console.rb#38
  def reopen; end

  private

  # source://logging//lib/logging/appenders/console.rb#49
  def open_fd; end
end

# source://logging//lib/logging/appenders/file.rb#11
class Logging::Appenders::File < ::Logging::Appenders::IO
  # source://logging//lib/logging/appenders/file.rb#45
  def initialize(name, opts = T.unsafe(nil)); end

  # source://logging//lib/logging/appenders/file.rb#61
  def filename; end

  # source://logging//lib/logging/appenders/file.rb#66
  def reopen; end

  protected

  # source://logging//lib/logging/appenders/file.rb#99
  def create_file; end

  # source://logging//lib/logging/appenders/file.rb#92
  def open_file; end

  # source://logging//lib/logging/appenders/file.rb#81
  def truncate; end

  class << self
    # source://logging//lib/logging/appenders/file.rb#22
    def assert_valid_logfile(fn); end
  end
end

# source://logging//lib/logging/appenders/io.rb#12
class Logging::Appenders::IO < ::Logging::Appender
  include ::Logging::Appenders::Buffering

  # source://logging//lib/logging/appenders/io.rb#26
  def initialize(name, io, opts = T.unsafe(nil)); end

  # source://logging//lib/logging/appenders/io.rb#46
  def close(*args); end

  # source://logging//lib/logging/appenders/io.rb#18
  def close_method; end

  # source://logging//lib/logging/appenders/io.rb#18
  def close_method=(_arg0); end

  # source://logging//lib/logging/appenders/io.rb#64
  def reopen; end

  private

  # source://logging//lib/logging/appenders/io.rb#74
  def canonical_write(str); end

  # source://logging//lib/logging/appenders/io.rb#83
  def handle_internal_error(err); end
end

# source://logging//lib/logging/appenders/rolling_file.rb#45
class Logging::Appenders::RollingFile < ::Logging::Appenders::IO
  # source://logging//lib/logging/appenders/rolling_file.rb#86
  def initialize(name, opts = T.unsafe(nil)); end

  # source://logging//lib/logging/appenders/rolling_file.rb#123
  def filename; end

  # source://logging//lib/logging/appenders/rolling_file.rb#130
  def reopen; end

  private

  # source://logging//lib/logging/appenders/rolling_file.rb#234
  def age_fn_mtime; end

  # source://logging//lib/logging/appenders/rolling_file.rb#244
  def build_singleton_methods; end

  # source://logging//lib/logging/appenders/rolling_file.rb#178
  def canonical_write(str); end

  # source://logging//lib/logging/appenders/rolling_file.rb#162
  def copy_file; end

  # source://logging//lib/logging/appenders/rolling_file.rb#168
  def copy_file_mtime; end

  # source://logging//lib/logging/appenders/rolling_file.rb#219
  def copy_truncate; end

  # source://logging//lib/logging/appenders/rolling_file.rb#152
  def create_file; end

  # source://logging//lib/logging/appenders/rolling_file.rb#145
  def open_file; end

  # source://logging//lib/logging/appenders/rolling_file.rb#203
  def roll_required?; end
end

# source://logging//lib/logging/appenders/rolling_file.rb#276
class Logging::Appenders::RollingFile::Roller
  # source://logging//lib/logging/appenders/rolling_file.rb#290
  def initialize(filename, age: T.unsafe(nil), size: T.unsafe(nil), roll_by: T.unsafe(nil), keep: T.unsafe(nil)); end

  # source://logging//lib/logging/appenders/rolling_file.rb#338
  def copy_file; end

  # source://logging//lib/logging/appenders/rolling_file.rb#329
  def filename; end

  # source://logging//lib/logging/appenders/rolling_file.rb#356
  def format; end

  # source://logging//lib/logging/appenders/rolling_file.rb#346
  def glob; end

  # source://logging//lib/logging/appenders/rolling_file.rb#325
  def keep; end

  # source://logging//lib/logging/appenders/rolling_file.rb#326
  def roll; end

  # source://logging//lib/logging/appenders/rolling_file.rb#326
  def roll=(_arg0); end

  # source://logging//lib/logging/appenders/rolling_file.rb#325
  def roll_by; end

  # source://logging//lib/logging/appenders/rolling_file.rb#418
  def roll_by_date(files); end

  # source://logging//lib/logging/appenders/rolling_file.rb#387
  def roll_by_number(files); end

  # source://logging//lib/logging/appenders/rolling_file.rb#368
  def roll_files; end
end

# source://logging//lib/logging/appenders/rolling_file.rb#279
Logging::Appenders::RollingFile::Roller::RGXP = T.let(T.unsafe(nil), Regexp)

# source://logging//lib/logging/appenders/console.rb#65
class Logging::Appenders::Stderr < ::Logging::Appenders::Console; end

# source://logging//lib/logging/appenders/console.rb#62
class Logging::Appenders::Stdout < ::Logging::Appenders::Console; end

# source://logging//lib/logging/appenders/string_io.rb#14
class Logging::Appenders::StringIo < ::Logging::Appenders::IO
  # source://logging//lib/logging/appenders/string_io.rb#25
  def initialize(name, opts = T.unsafe(nil)); end

  # source://logging//lib/logging/appenders/string_io.rb#53
  def clear; end

  # source://logging//lib/logging/appenders/string_io.rb#64
  def read(*args); end

  # source://logging//lib/logging/appenders/string_io.rb#64
  def readline(*args); end

  # source://logging//lib/logging/appenders/string_io.rb#64
  def readlines(*args); end

  # source://logging//lib/logging/appenders/string_io.rb#36
  def reopen; end

  # source://logging//lib/logging/appenders/string_io.rb#53
  def reset; end

  # source://logging//lib/logging/appenders/string_io.rb#17
  def sio; end
end

# source://logging//lib/logging/appenders/string_io.rb#80
module Logging::Appenders::StringIo::IoToS
  # source://logging//lib/logging/appenders/string_io.rb#81
  def to_s; end
end

# source://logging//lib/logging/appenders/syslog.rb#19
class Logging::Appenders::Syslog < ::Logging::Appender
  include ::Syslog::Option
  include ::Syslog::Facility
  include ::Syslog::Level
  include ::Syslog::Macros
  include ::Syslog::Constants
  extend ::Syslog::Macros

  # source://logging//lib/logging/appenders/syslog.rb#95
  def initialize(name, opts = T.unsafe(nil)); end

  # source://logging//lib/logging/appenders/syslog.rb#139
  def close(footer = T.unsafe(nil)); end

  # source://logging//lib/logging/appenders/syslog.rb#151
  def closed?; end

  # source://logging//lib/logging/appenders/syslog.rb#125
  def map=(levels); end

  # source://logging//lib/logging/appenders/syslog.rb#159
  def reopen; end

  private

  # source://logging//lib/logging/appenders/syslog.rb#201
  def syslog_level_num(level); end

  # source://logging//lib/logging/appenders/syslog.rb#181
  def write(event); end
end

# source://logging//lib/logging/color_scheme.rb#31
class Logging::ColorScheme
  # source://logging//lib/logging/color_scheme.rb#121
  def initialize(name, opts = T.unsafe(nil)); end

  # source://logging//lib/logging/color_scheme.rb#166
  def [](color_tag); end

  # source://logging//lib/logging/color_scheme.rb#172
  def []=(color_tag, constants); end

  # source://logging//lib/logging/color_scheme.rb#184
  def color(string, *colors); end

  # source://logging//lib/logging/color_scheme.rb#160
  def include?(color_tag); end

  # source://logging//lib/logging/color_scheme.rb#154
  def levels?; end

  # source://logging//lib/logging/color_scheme.rb#148
  def lines?; end

  # source://logging//lib/logging/color_scheme.rb#140
  def load_from_hash(h); end

  private

  # source://logging//lib/logging/color_scheme.rb#206
  def to_constant(v); end

  # source://logging//lib/logging/color_scheme.rb#200
  def to_key(t); end

  class << self
    # source://logging//lib/logging/color_scheme.rb#36
    def [](name); end

    # source://logging//lib/logging/color_scheme.rb#42
    def []=(name, value); end

    # source://logging//lib/logging/color_scheme.rb#49
    def reset; end
  end
end

# source://logging//lib/logging/color_scheme.rb#225
Logging::ColorScheme::BLACK = T.let(T.unsafe(nil), String)

# source://logging//lib/logging/color_scheme.rb#221
Logging::ColorScheme::BLINK = T.let(T.unsafe(nil), String)

# source://logging//lib/logging/color_scheme.rb#229
Logging::ColorScheme::BLUE = T.let(T.unsafe(nil), String)

# source://logging//lib/logging/color_scheme.rb#217
Logging::ColorScheme::BOLD = T.let(T.unsafe(nil), String)

# source://logging//lib/logging/color_scheme.rb#246
Logging::ColorScheme::BRIGHT_BLUE = T.let(T.unsafe(nil), String)

# source://logging//lib/logging/color_scheme.rb#248
Logging::ColorScheme::BRIGHT_CYAN = T.let(T.unsafe(nil), String)

# source://logging//lib/logging/color_scheme.rb#244
Logging::ColorScheme::BRIGHT_GREEN = T.let(T.unsafe(nil), String)

# source://logging//lib/logging/color_scheme.rb#247
Logging::ColorScheme::BRIGHT_MAGENTA = T.let(T.unsafe(nil), String)

# source://logging//lib/logging/color_scheme.rb#243
Logging::ColorScheme::BRIGHT_RED = T.let(T.unsafe(nil), String)

# source://logging//lib/logging/color_scheme.rb#249
Logging::ColorScheme::BRIGHT_WHITE = T.let(T.unsafe(nil), String)

# source://logging//lib/logging/color_scheme.rb#245
Logging::ColorScheme::BRIGHT_YELLOW = T.let(T.unsafe(nil), String)

# source://logging//lib/logging/color_scheme.rb#213
Logging::ColorScheme::CLEAR = T.let(T.unsafe(nil), String)

# source://logging//lib/logging/color_scheme.rb#223
Logging::ColorScheme::CONCEALED = T.let(T.unsafe(nil), String)

# source://logging//lib/logging/color_scheme.rb#231
Logging::ColorScheme::CYAN = T.let(T.unsafe(nil), String)

# source://logging//lib/logging/color_scheme.rb#218
Logging::ColorScheme::DARK = T.let(T.unsafe(nil), String)

# source://logging//lib/logging/color_scheme.rb#216
Logging::ColorScheme::ERASE_CHAR = T.let(T.unsafe(nil), String)

# source://logging//lib/logging/color_scheme.rb#215
Logging::ColorScheme::ERASE_LINE = T.let(T.unsafe(nil), String)

# source://logging//lib/logging/color_scheme.rb#227
Logging::ColorScheme::GREEN = T.let(T.unsafe(nil), String)

# source://logging//lib/logging/color_scheme.rb#230
Logging::ColorScheme::MAGENTA = T.let(T.unsafe(nil), String)

# source://logging//lib/logging/color_scheme.rb#234
Logging::ColorScheme::ON_BLACK = T.let(T.unsafe(nil), String)

# source://logging//lib/logging/color_scheme.rb#238
Logging::ColorScheme::ON_BLUE = T.let(T.unsafe(nil), String)

# source://logging//lib/logging/color_scheme.rb#254
Logging::ColorScheme::ON_BRIGHT_BLUE = T.let(T.unsafe(nil), String)

# source://logging//lib/logging/color_scheme.rb#256
Logging::ColorScheme::ON_BRIGHT_CYAN = T.let(T.unsafe(nil), String)

# source://logging//lib/logging/color_scheme.rb#252
Logging::ColorScheme::ON_BRIGHT_GREEN = T.let(T.unsafe(nil), String)

# source://logging//lib/logging/color_scheme.rb#255
Logging::ColorScheme::ON_BRIGHT_MAGENTA = T.let(T.unsafe(nil), String)

# source://logging//lib/logging/color_scheme.rb#251
Logging::ColorScheme::ON_BRIGHT_RED = T.let(T.unsafe(nil), String)

# source://logging//lib/logging/color_scheme.rb#257
Logging::ColorScheme::ON_BRIGHT_WHITE = T.let(T.unsafe(nil), String)

# source://logging//lib/logging/color_scheme.rb#253
Logging::ColorScheme::ON_BRIGHT_YELLOW = T.let(T.unsafe(nil), String)

# source://logging//lib/logging/color_scheme.rb#240
Logging::ColorScheme::ON_CYAN = T.let(T.unsafe(nil), String)

# source://logging//lib/logging/color_scheme.rb#236
Logging::ColorScheme::ON_GREEN = T.let(T.unsafe(nil), String)

# source://logging//lib/logging/color_scheme.rb#239
Logging::ColorScheme::ON_MAGENTA = T.let(T.unsafe(nil), String)

# source://logging//lib/logging/color_scheme.rb#235
Logging::ColorScheme::ON_RED = T.let(T.unsafe(nil), String)

# source://logging//lib/logging/color_scheme.rb#241
Logging::ColorScheme::ON_WHITE = T.let(T.unsafe(nil), String)

# source://logging//lib/logging/color_scheme.rb#237
Logging::ColorScheme::ON_YELLOW = T.let(T.unsafe(nil), String)

# source://logging//lib/logging/color_scheme.rb#226
Logging::ColorScheme::RED = T.let(T.unsafe(nil), String)

# source://logging//lib/logging/color_scheme.rb#214
Logging::ColorScheme::RESET = T.let(T.unsafe(nil), String)

# source://logging//lib/logging/color_scheme.rb#222
Logging::ColorScheme::REVERSE = T.let(T.unsafe(nil), String)

# source://logging//lib/logging/color_scheme.rb#219
Logging::ColorScheme::UNDERLINE = T.let(T.unsafe(nil), String)

# source://logging//lib/logging/color_scheme.rb#220
Logging::ColorScheme::UNDERSCORE = T.let(T.unsafe(nil), String)

# source://logging//lib/logging/color_scheme.rb#232
Logging::ColorScheme::WHITE = T.let(T.unsafe(nil), String)

# source://logging//lib/logging/color_scheme.rb#228
Logging::ColorScheme::YELLOW = T.let(T.unsafe(nil), String)

# source://logging//lib/logging.rb#26
Logging::DEFAULT_CAUSE_DEPTH = T.let(T.unsafe(nil), Integer)

# source://logging//lib/logging/diagnostic_context.rb#414
Logging::DIAGNOSTIC_MUTEX = T.let(T.unsafe(nil), Thread::Mutex)

# source://logging//lib/logging/filter.rb#9
class Logging::Filter
  # source://logging//lib/logging/filter.rb#13
  def initialize; end

  # source://logging//lib/logging/filter.rb#21
  def allow(event); end
end

# source://logging//lib/logging/filters.rb#2
module Logging::Filters; end

# source://logging//lib/logging/filters/level.rb#8
class Logging::Filters::Level < ::Logging::Filter
  # source://logging//lib/logging/filters/level.rb#17
  def initialize(*levels); end

  # source://logging//lib/logging/filters/level.rb#27
  def allow(event); end
end

# source://logging//lib/logging/diagnostic_context.rb#418
Logging::INHERIT_CONTEXT = T.let(T.unsafe(nil), TrueClass)

# source://logging//lib/logging.rb#24
Logging::LEVELS = T.let(T.unsafe(nil), Hash)

# source://logging//lib/logging.rb#22
Logging::LIBPATH = T.let(T.unsafe(nil), String)

# source://logging//lib/logging.rb#25
Logging::LNAMES = T.let(T.unsafe(nil), Array)

# source://logging//lib/logging/layout.rb#12
class Logging::Layout
  # source://logging//lib/logging/layout.rb#31
  def initialize(opts = T.unsafe(nil)); end

  # source://logging//lib/logging/layout.rb#114
  def apply_utc_offset(time); end

  # source://logging//lib/logging/layout.rb#65
  def backtrace; end

  # source://logging//lib/logging/layout.rb#55
  def backtrace=(value); end

  # source://logging//lib/logging/layout.rb#65
  def backtrace?; end

  # source://logging//lib/logging/layout.rb#105
  def cause_depth; end

  # source://logging//lib/logging/layout.rb#95
  def cause_depth=(value); end

  # source://logging//lib/logging/layout.rb#147
  def footer; end

  # source://logging//lib/logging/layout.rb#132
  def format(event); end

  # source://logging//lib/logging/layout.rb#185
  def format_cause(e, lines); end

  # source://logging//lib/logging/layout.rb#214
  def format_cause_backtrace(e, cause); end

  # source://logging//lib/logging/layout.rb#156
  def format_obj(obj); end

  # source://logging//lib/logging/layout.rb#140
  def header; end

  # source://logging//lib/logging/layout.rb#254
  def try_json(obj); end

  # source://logging//lib/logging/layout.rb#241
  def try_yaml(obj); end

  # source://logging//lib/logging/layout.rb#91
  def utc_offset; end

  # source://logging//lib/logging/layout.rb#80
  def utc_offset=(value); end
end

# source://logging//lib/logging/layouts.rb#3
module Logging::Layouts
  class << self
    # source://logging//lib/logging/layouts/basic.rb#6
    def basic(*args); end

    # source://logging//lib/logging/layouts/parseable.rb#13
    def json(*args); end

    # source://logging//lib/logging/layouts/parseable.rb#7
    def parseable; end

    # source://logging//lib/logging/layouts/pattern.rb#6
    def pattern(*args); end

    # source://logging//lib/logging/layouts/parseable.rb#19
    def yaml(*args); end
  end
end

# source://logging//lib/logging/layouts/basic.rb#22
class Logging::Layouts::Basic < ::Logging::Layout
  # source://logging//lib/logging/layouts/basic.rb#30
  def format(event); end
end

# source://logging//lib/logging/layouts/parseable.rb#95
class Logging::Layouts::Parseable < ::Logging::Layout
  # source://logging//lib/logging/layouts/parseable.rb#184
  def initialize(opts = T.unsafe(nil)); end

  # source://logging//lib/logging/layouts/parseable.rb#244
  def format_cause(e); end

  # source://logging//lib/logging/layouts/parseable.rb#219
  def format_obj(obj); end

  # source://logging//lib/logging/layouts/parseable.rb#191
  def items; end

  # source://logging//lib/logging/layouts/parseable.rb#199
  def items=(ary); end

  private

  # source://logging//lib/logging/layouts/parseable.rb#274
  def create_format_method; end

  # source://logging//lib/logging/layouts/parseable.rb#283
  def iso8601_format(time); end

  class << self
    # source://logging//lib/logging/layouts/parseable.rb#140
    def create_json_format_method(layout); end

    # source://logging//lib/logging/layouts/parseable.rb#122
    def create_yaml_format_method(layout); end

    # source://logging//lib/logging/layouts/parseable.rb#159
    def json(opts = T.unsafe(nil)); end

    # source://logging//lib/logging/layouts/parseable.rb#170
    def yaml(opts = T.unsafe(nil)); end
  end
end

# source://logging//lib/logging/layouts/parseable.rb#99
Logging::Layouts::Parseable::DIRECTIVE_TABLE = T.let(T.unsafe(nil), Hash)

# source://logging//lib/logging/layouts/pattern.rb#150
class Logging::Layouts::Pattern < ::Logging::Layout
  # source://logging//lib/logging/layouts/pattern.rb#219
  def initialize(opts = T.unsafe(nil)); end

  # source://logging//lib/logging/layouts/pattern.rb#283
  def _meta_eval(code, file = T.unsafe(nil), line = T.unsafe(nil)); end

  # source://logging//lib/logging/layouts/pattern.rb#241
  def color_scheme; end

  # source://logging//lib/logging/layouts/pattern.rb#241
  def date_method; end

  # source://logging//lib/logging/layouts/pattern.rb#272
  def date_method=(var); end

  # source://logging//lib/logging/layouts/pattern.rb#241
  def date_pattern; end

  # source://logging//lib/logging/layouts/pattern.rb#259
  def date_pattern=(var); end

  # source://logging//lib/logging/layouts/pattern.rb#241
  def pattern; end

  # source://logging//lib/logging/layouts/pattern.rb#248
  def pattern=(var); end

  class << self
    # source://logging//lib/logging/layouts/pattern.rb#164
    def create_date_format_methods(pl); end

    # source://logging//lib/logging/layouts/pattern.rb#190
    def create_format_method(pl); end
  end
end

# source://logging//lib/logging/layouts/pattern.rb#292
class Logging::Layouts::Pattern::FormatMethodBuilder
  # source://logging//lib/logging/layouts/pattern.rb#350
  def initialize(pattern_layout); end

  # source://logging//lib/logging/layouts/pattern.rb#385
  def build_code; end

  # source://logging//lib/logging/layouts/pattern.rb#412
  def build_format_string; end

  # source://logging//lib/logging/layouts/pattern.rb#340
  def color_scheme; end

  # source://logging//lib/logging/layouts/pattern.rb#361
  def colorize?; end

  # source://logging//lib/logging/layouts/pattern.rb#371
  def colorize_levels?; end

  # source://logging//lib/logging/layouts/pattern.rb#366
  def colorize_lines?; end

  # source://logging//lib/logging/layouts/pattern.rb#342
  def format_string; end

  # source://logging//lib/logging/layouts/pattern.rb#552
  def handle_directives(format, directive, precision); end

  # source://logging//lib/logging/layouts/pattern.rb#483
  def handle_level(format, directive, precision); end

  # source://logging//lib/logging/layouts/pattern.rb#452
  def handle_logger(format, directive, slice); end

  # source://logging//lib/logging/layouts/pattern.rb#511
  def handle_mdc(format, directive, key); end

  # source://logging//lib/logging/layouts/pattern.rb#532
  def handle_ndc(format, directive, separator); end

  # source://logging//lib/logging/layouts/pattern.rb#338
  def layout; end

  # source://logging//lib/logging/layouts/pattern.rb#343
  def name_map_count; end

  # source://logging//lib/logging/layouts/pattern.rb#343
  def name_map_count=(_arg0); end

  # source://logging//lib/logging/layouts/pattern.rb#339
  def pattern; end

  # source://logging//lib/logging/layouts/pattern.rb#339
  def pattern=(_arg0); end

  # source://logging//lib/logging/layouts/pattern.rb#341
  def sprintf_args; end
end

# source://logging//lib/logging/layouts/pattern.rb#322
Logging::Layouts::Pattern::FormatMethodBuilder::COLOR_ALIAS_TABLE = T.let(T.unsafe(nil), Hash)

# source://logging//lib/logging/layouts/pattern.rb#300
Logging::Layouts::Pattern::FormatMethodBuilder::DIRECTIVE_RGXP = T.let(T.unsafe(nil), Regexp)

# source://logging//lib/logging/layouts/pattern.rb#303
Logging::Layouts::Pattern::FormatMethodBuilder::DIRECTIVE_TABLE = T.let(T.unsafe(nil), Hash)

# source://logging//lib/logging/layouts/pattern.rb#155
Logging::Layouts::Pattern::ISO8601 = T.let(T.unsafe(nil), String)

# source://logging//lib/logging/log_event.rb#5
class Logging::LogEvent
  # source://logging//lib/logging/log_event.rb#29
  def initialize(logger, level, data, caller_tracing); end

  # source://logging//lib/logging/log_event.rb#19
  def data; end

  # source://logging//lib/logging/log_event.rb#19
  def data=(_arg0); end

  # source://logging//lib/logging/log_event.rb#19
  def file; end

  # source://logging//lib/logging/log_event.rb#19
  def file=(_arg0); end

  # source://logging//lib/logging/log_event.rb#19
  def level; end

  # source://logging//lib/logging/log_event.rb#19
  def level=(_arg0); end

  # source://logging//lib/logging/log_event.rb#19
  def line; end

  # source://logging//lib/logging/log_event.rb#19
  def line=(_arg0); end

  # source://logging//lib/logging/log_event.rb#19
  def logger; end

  # source://logging//lib/logging/log_event.rb#19
  def logger=(_arg0); end

  # source://logging//lib/logging/log_event.rb#19
  def method_name; end

  # source://logging//lib/logging/log_event.rb#19
  def method_name=(_arg0); end

  # source://logging//lib/logging/log_event.rb#19
  def time; end

  # source://logging//lib/logging/log_event.rb#19
  def time=(_arg0); end
end

# source://logging//lib/logging/log_event.rb#15
Logging::LogEvent::CALLER_INDEX = T.let(T.unsafe(nil), Integer)

# source://logging//lib/logging/log_event.rb#13
Logging::LogEvent::CALLER_RGXP = T.let(T.unsafe(nil), Regexp)

# source://logging//lib/logging/logger.rb#25
class Logging::Logger
  include ::Logging::RailsCompat

  # source://logging//lib/logging/logger.rb#154
  def initialize(name); end

  # source://logging//lib/logging/logger.rb#185
  def <<(msg); end

  # source://logging//lib/logging/logger.rb#170
  def <=>(other); end

  # source://logging//lib/logging/logger.rb#472
  def _dump_configuration(indent = T.unsafe(nil)); end

  # source://logging//lib/logging/logger.rb#441
  def _meta_eval(code, file = T.unsafe(nil), line = T.unsafe(nil)); end

  # source://logging//lib/logging/logger.rb#452
  def _setup(name, opts = T.unsafe(nil)); end

  # source://logging//lib/logging/logger.rb#215
  def add(lvl, data = T.unsafe(nil), progname = T.unsafe(nil)); end

  # source://logging//lib/logging/logger.rb#349
  def add_appenders(*args); end

  # source://logging//lib/logging/logger.rb#130
  def additive; end

  # source://logging//lib/logging/logger.rb#238
  def additive=(val); end

  # source://logging//lib/logging/logger.rb#328
  def appenders; end

  # source://logging//lib/logging/logger.rb#338
  def appenders=(args); end

  # source://logging//lib/logging/logger.rb#130
  def caller_tracing; end

  # source://logging//lib/logging/logger.rb#253
  def caller_tracing=(val); end

  # source://logging//lib/logging/logger.rb#385
  def clear_appenders; end

  # source://phobos/2.1.4/lib/phobos.rb#42
  def formatter=(*args); end

  # source://logging//lib/logging/logger.rb#322
  def has_own_level?; end

  # source://logging//lib/logging/logger.rb#267
  def level; end

  # source://logging//lib/logging/logger.rb#300
  def level=(level); end

  # source://logging//lib/logging/logger.rb#130
  def name; end

  # source://logging//lib/logging/logger.rb#130
  def parent; end

  # source://phobos/2.1.4/lib/phobos.rb#48
  def pop_tags(*args); end

  # source://phobos/2.1.4/lib/phobos.rb#45
  def push_tags(*args); end

  # source://logging//lib/logging/logger.rb#366
  def remove_appenders(*args); end

  # source://logging//lib/logging/logger.rb#185
  def write(msg); end

  protected

  # source://logging//lib/logging/logger.rb#420
  def define_log_methods(force = T.unsafe(nil), code = T.unsafe(nil)); end

  # source://logging//lib/logging/logger.rb#405
  def log_event(event); end

  # source://logging//lib/logging/logger.rb#396
  def parent=(parent); end

  class << self
    # source://logging//lib/logging/logger.rb#43
    def [](name); end

    # source://logging//lib/logging/logger.rb#85
    def define_log_methods(logger); end

    def instantiate(*_arg0); end

    # source://logging//lib/logging/logger.rb#95
    def log_methods_for_level(level); end

    # source://logging//lib/logging/logger.rb#126
    def mutex; end

    # source://logging//lib/logging/logger.rb#38
    def new(*args); end

    # source://logging//lib/logging/logger.rb#28
    def root; end
  end
end

# source://logging//lib/logging.rb#258
Logging::MAX_LEVEL_LENGTH = T.let(T.unsafe(nil), Integer)

# source://logging//lib/logging/diagnostic_context.rb#33
module Logging::MappedDiagnosticContext
  extend ::Logging::MappedDiagnosticContext

  # source://logging//lib/logging/diagnostic_context.rb#62
  def [](key); end

  # source://logging//lib/logging/diagnostic_context.rb#50
  def []=(key, value); end

  # source://logging//lib/logging/diagnostic_context.rb#126
  def clear; end

  # source://logging//lib/logging/diagnostic_context.rb#196
  def clear_context; end

  # source://logging//lib/logging/diagnostic_context.rb#160
  def context; end

  # source://logging//lib/logging/diagnostic_context.rb#73
  def delete(key); end

  # source://logging//lib/logging/diagnostic_context.rb#229
  def flatten(ary); end

  # source://logging//lib/logging/diagnostic_context.rb#140
  def inherit(obj); end

  # source://logging//lib/logging/diagnostic_context.rb#190
  def peek; end

  # source://logging//lib/logging/diagnostic_context.rb#112
  def pop; end

  # source://logging//lib/logging/diagnostic_context.rb#99
  def push(hash); end

  # source://logging//lib/logging/diagnostic_context.rb#211
  def sanitize(hash, target = T.unsafe(nil)); end

  # source://logging//lib/logging/diagnostic_context.rb#179
  def stack; end

  # source://logging//lib/logging/diagnostic_context.rb#86
  def update(hash); end
end

# source://logging//lib/logging/diagnostic_context.rb#37
Logging::MappedDiagnosticContext::NAME = T.let(T.unsafe(nil), Symbol)

# source://logging//lib/logging/diagnostic_context.rb#40
Logging::MappedDiagnosticContext::STACK_NAME = T.let(T.unsafe(nil), Symbol)

# source://logging//lib/logging/diagnostic_context.rb#277
module Logging::NestedDiagnosticContext
  extend ::Logging::NestedDiagnosticContext

  # source://logging//lib/logging/diagnostic_context.rb#291
  def <<(message); end

  # source://logging//lib/logging/diagnostic_context.rb#332
  def clear; end

  # source://logging//lib/logging/diagnostic_context.rb#363
  def context; end

  # source://logging//lib/logging/diagnostic_context.rb#345
  def inherit(obj); end

  # source://logging//lib/logging/diagnostic_context.rb#322
  def peek; end

  # source://logging//lib/logging/diagnostic_context.rb#311
  def pop; end

  # source://logging//lib/logging/diagnostic_context.rb#291
  def push(message); end
end

# source://logging//lib/logging/diagnostic_context.rb#281
Logging::NestedDiagnosticContext::NAME = T.let(T.unsafe(nil), Symbol)

# source://logging//lib/logging.rb#23
Logging::PATH = T.let(T.unsafe(nil), String)

# source://logging//lib/logging.rb#28
module Logging::Plugins; end

# source://logging//lib/logging/proxy.rb#23
class Logging::Proxy
  # source://logging//lib/logging/proxy.rb#35
  def initialize(object, &block); end

  # source://logging//lib/logging/proxy.rb#52
  def method_missing(name, *args, &block); end
end

# source://logging//lib/logging/proxy.rb#26
Logging::Proxy::KEEPERS = T.let(T.unsafe(nil), Regexp)

# source://logging//lib/logging/rails_compat.rb#9
module Logging::RailsCompat
  # source://logging//lib/logging/rails_compat.rb#12
  def formatter; end

  # source://logging//lib/logging/rails_compat.rb#21
  def silence(*args); end
end

# source://logging//lib/logging/repository.rb#10
class Logging::Repository
  include ::Singleton
  extend ::Singleton::SingletonClassMethods

  # source://logging//lib/logging/repository.rb#20
  def initialize; end

  # source://logging//lib/logging/repository.rb#56
  def [](key); end

  # source://logging//lib/logging/repository.rb#68
  def []=(key, val); end

  # source://logging//lib/logging/repository.rb#146
  def children(parent); end

  # source://logging//lib/logging/repository.rb#110
  def delete(key); end

  # source://logging//lib/logging/repository.rb#81
  def fetch(key); end

  # source://logging//lib/logging/repository.rb#94
  def has_logger?(key); end

  # source://logging//lib/logging/repository.rb#132
  def parent(key); end

  # source://logging//lib/logging/repository.rb#180
  def parent_name(key); end

  # source://logging//lib/logging/repository.rb#167
  def to_key(key); end

  class << self
    # source://logging//lib/logging/repository.rb#193
    def reset; end
  end
end

# source://logging//lib/logging/repository.rb#13
Logging::Repository::PATH_DELIMITER = T.let(T.unsafe(nil), String)

# source://logging//lib/logging/root_logger.rb#8
class Logging::RootLogger < ::Logging::Logger
  # source://logging//lib/logging/root_logger.rb#23
  def initialize; end

  # source://logging//lib/logging/root_logger.rb#40
  def <=>(other); end

  # source://logging//lib/logging/root_logger.rb#15
  def level; end

  # source://logging//lib/logging/root_logger.rb#54
  def level=(level); end
end

# source://logging//lib/logging/version.rb#2
Logging::VERSION = T.let(T.unsafe(nil), String)

# source://logging//lib/logging/utils.rb#36
class Module
  # source://logging//lib/logging/utils.rb#47
  def logger_name; end
end

# source://logging//lib/logging/utils.rb#146
class ReentrantMutex < ::Thread::Mutex
  # source://logging//lib/logging/utils.rb#148
  def initialize; end

  def original_synchronize; end

  # source://logging//lib/logging/utils.rb#155
  def synchronize; end
end

# source://logging//lib/logging/utils.rb#6
class String
  include ::Comparable

  # source://logging//lib/logging/utils.rb#17
  def shrink(width, ellipses = T.unsafe(nil)); end
end

# source://logging//lib/logging/diagnostic_context.rb#429
class Thread
  class << self
    # source://logging//lib/logging/diagnostic_context.rb#435
    def fork(*a, &b); end

    # source://logging//lib/logging/diagnostic_context.rb#435
    def new(*a, &b); end

    # source://logging//lib/logging/diagnostic_context.rb#435
    def start(*a, &b); end

    private

    # source://logging//lib/logging/diagnostic_context.rb#457
    def create_with_logging_context(m, *a, &b); end
  end
end
